[{"title":"Hello World","url":"/2022/12/23/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"转载：《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信》及其批判信","url":"/2021/12/04/1202ccf/","content":"关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志:\n首先，请允许我对昨日发生在贵学会的事表达诚挚的告慰和深切的哀思。\n昨日，即公历公元二零二一年十二月三日星期五，农历辛丑年十月廿九日。在这个清列的冬日，在夕阳已没入北京地平线下的晚六时零五分七秒，一篇题为《关于个别选手在NOIP2021中使用暴戾语言的处罚公告》的公文赫然出现在贵学会所主办的全国青少年信息学奥林匹克竞赛的官网上。这篇文章实在可恶，作者其人对学会攻击之情、抹黑之义溢于言表。我见此文，不免义愤填膺，一日不为学会据理力争、正本清源，则寝食难安。\n在文中，此人决定取消5名选手的NOIP2021成绩;禁止其参加NOI系列活动和认证一年;并对选手所在学校和指导教师通报批评。那么，这些学生到底违反了哪条纪律规定，以至于被取消成绩、禁赛一年呢?\n此人一开篇便给出答案了∶这些学生在个人提交程序中使用对CCF的侮辱性网络暴戾语言’∶好吧，原来这些学生是惹了学会不高兴。可是，学会所主办的NOI及其附属NOIP毕竟是一项明确列入《教育部办公厅关于公布2021—2022学年面向中小学生的全国性竞赛活动的通知》的全国性竞赛。这项被教育部认可的竞赛的成绩,总还是和强基计划、I0l集训队保送这些升学机会有所联系的。在这项竞赛中取消选手成绩的能力，不得不说是一种公权力，而公权力向来是法无授权不可为的。想来发文者也懂得此法治道理（毕竟他是熟悉社会主义核心价值观的)，因此他总要找一项规定来安在学生们的头上。可是，他翻遍了故纸堆，不论是人大通过的法律、教育部制订的规章、主管部门的《中国科协全国五项学科竞赛条例》，还是计算机学会自己的《全国青少年信息学奥林匹克竞赛条例》《全国青少年信息学奥林匹克联赛组织指南》，竟然都没规定暴戾语言是一项足以危害竞赛公平、取消成绩的罪行呢!\n此人不仅找不到罪行，反倒在《民法典》和司法解释中找到了关于名誉侵权的一般责任，竟然是责令教育、公开道歉、消除影响、赔偿损失。毕竟，中国计算机学会是个独立社团法人。这下，不是和取消成绩的目的毫无关系了吗?于是此人只好寻找那些捕风捉影的帽子了。别说，还真让他找到了一个!\n这个帽子是什么呢?这就是国务院办公厅印发的《关于全面加强新时代语言文字工作的意见》。国务院的《意见》的第八条写道: .…加强语言文明教育，强化对互联网等各类新媒体语言文字使用的规范和管理，坚决遏阻庸俗暴戾网络语言传播，建设健康文明的网络语言环境。…”P瞧O瞧，只要我把程序代码定义为”互联网新媒体语言”把取消选手成绩和禁赛定义为“教育”这不就是”贯彻落实国务院意见”了么?至于”教育”到底能否包括在无具体规定的情况下取消成绩并禁赛”，《意见》二十一条中讲的“夯实语言文字工作法治基础”又有何含义，那些”暴戾”的参赛者怎么可能想得到呢!\n此人想到这里，似乎终于松了一口气而觉得自己的处罚合理了，似乎终于觉得要求”批评教育道歉赔偿′”和”禁赛”只是处罚的轻重之别了，似乎终于说明学会的公权力可以躲在对国务院文件的随意打扮后头，绕开繁杂的规范为所欲为了。于是，他暂且放下了为取消成绩寻找依据的脚步，转到另一件事上来了。\n另一件事是什么呢?那就是按照他写出的处罚理由”暴戾语言”，违犯的学生竟达到数百之多哩!在NOIP2021中仅仅程序代码同时含有’fuck和c两个英文词的选手，就至少有109(壹佰零玫)人。那么，为了“建设健康文明的网络语言环境的索高目的，把这些人全部取消成绩禁赛一年不就好了吗?当然不好了!毕竟要是毫无规定就禁赛数百名选手，必然导致竞赛的大反对，那怎么达到安稳”教育的目的呢!可是，又如何能让自己在数百选手中只看到五个人的暴戾”呢?当然是因为只有他们五个人被”实名举报”了!这样，要是有人问如何举报’，只要搬出对举报人保密的义务;要是有人问责成相关省组织单位进行情况调查为何漏掉了其余数十上百的选手，只要怪省组织单位调查不力，责成重新调查;要是有人问为何不受理其它举报，只要说公示期已经结束不就好了嘛!谁让你们愚蠢，不看到处罚公告就想不到还可以通过举报暴戾语言来取消别人成绩呢?\n既然把这两件事——即为何能无视规定条例随意处罚学生，和处罚学生为何在数百人中独爱五人–论述清楚，此人的公文也该作结了，只要最后署名中国计算机学会，就能把以上两个责任和歪理都推在独立社团法人、中国计算机学会的头上啦。只要于星期五傍晚六时发送公告，使学会于周末休息日难以应对，过了两天，事情自然生米煮成熟饭了!\n到挪时，被处罚的学校，痛感不公的同志诸君，将只会批判中国计算机学会滥用主办方权力，将未违反法律法规及竞赛条例的选手取消成绩并禁赛了。到那时，他们就还会搬出《中国科协全国五项学科竞赛条例》的第二十七、二十八条，声讨学会事实上擅自更改参赛学生的竞赛成绩，科协应当主管监督了。到那时，他们就怀疑这种无规定依据的选择性判罚给了利益输送、权力寻租以空间，或至少给了私相授受、恶意举报以机会了。到那时，他们就会在最低限度上，至少要求CCF撤回一切以程序中使用对CCF的侮辱性网络暴戾语言”为口实的无规判罚，公告承认错误、说明情况，以维护学科竞赛之教育公平和公信，并作坚决的斗争了!可是这一切，都和处罚公文的作者没有关系了。\n如此一篇欲陷学会于不义的公文，竟然堂而皇之地出现在学会主力的竞赛网站首页，不能不让关心学会、热爱计算机教育者痛心。但好在事情尚可收拾，只要立刻撤回一切以程序中使用对CCF的侮辱性网络暴戾语言”为口实的无规判罚，公告说明情况，以维护竞赛之教育公平和公信，广大师生自然会和公义、和法治站在一起,完善教育规范，消除暴戾风气，支持学会加强学科竞赛的精神文明建设。毕竟，当前师生还要借助学会主办的竞赛来参与和发展算法、计算机基础教育。朴素的公正愿望，满足这些也就可以缓和了!\n此致\n附则1:中国计算机学会主办全国青少年信息学奥林匹克竞赛网站上的处罚公告原文: https:&#x2F;www.noi.cn/xw/2021-12-03/750909.shtml33\n附录：关于个别选手在NOIP 2021中使用暴戾语言的处罚公告NOIP 2021于11月20日在全国31个赛区同时举行。竞赛整体进展平稳顺利，但也发现了极个别严重违反社会主义精神文明建设的行为。CCF现将情况和处罚公告如下。\n在NOIP申诉期内，我学会接到多封实名举报，指出个别选手提交的NOIP 2021个人程序中存在对CCF的侮辱性语言。经我学会NOI评测组核实，举报情况属实。我学会责成相关省组织单位进行情况调查。根据调查结果，相关选手确实在个人提交程序中输入了侮辱性等网络暴戾语言。\n根据NOIP规则，各省在赛后第一时间公示选手程序，是为了加强选手间的交流和学习，但是这些带有网络暴戾性质语言的程序，也在一定范围内广泛传播，严重破坏了NOI选手的整体形象和道德声誉，也给CCF造成了极为负面的社会影响。\n国务院办公厅近日印发的《关于全面加强新时代语言文字工作的意见》指出，要“加强语言文明教育，强化对互联网等各类新媒体语言文字使用的规范和管理，坚决遏阻庸俗暴戾网络语言传播，建设健康文明的网络语言环境。”\n为维护NOI竞赛秩序，遏制影响中学生身心健康发展的不良行为，CCF决定，取消GD-0081赖* 旭（华南师范大学中山附属中学）、GD-0785张* 铭（中山市中山纪念中学）、HA-0101王* 康（郑州市第十一中学）、SC-0027毛* 祥（成都外国语学校）、ZJ-0071姜*丞（浙江省衢州第二中学）的 NOIP 2021成绩；即日起，禁止其参加NOI系列活动和认证一年；并对选手所在学校和指导教师通报批评。\nCCF认为，在NOI系列竞赛和认证中，选手的道德培养是非常重要的部分。所有选手及其指导教师都应当在培养选手竞赛知识和能力的同时，加强选手的道德文明教育，使选手真正成为社会主义建设的有用之才。\n此公告。\n中国计算机学会\n2021年12月3日\n扩展阅读：批判《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会等的公开信》——全面、现实、严肃、深入地分析和解决问题\n理论一经掌握群众，也会变成物质力量。理论只要说服人，就能掌握群众，而理论只要彻底，就能说服人。所谓彻底，就是抓住事物的根本，而人的根本就是人本身。——卡尔•马克思 《&lt;黑格尔法哲学批判&gt;导言》\n\n一、《公开信》的目的和片面性我想，各位同学都读过《关于CCF无规定选择性取消NOIP选手成绩事件致中国计算机学会、中国计算机学会NOI科学委员会，并致杜子德同志的公开信》了。\n这封信的每一个字，每一句话，每一个段落和论证都是正确的。可是，它有一个最为错误的地方。\n那就是，它不够严肃。\n或者说，这封信是一个手段，它是为了一个目的而写的。\n这个目的是什么呢？那就是，要求撤回对5名选手的取消成绩和禁赛处罚。\n正是为了这个目的，它的标题把事件称作“无规定选择性取消NOIP选手成绩事件”，而不是事实的“CCF《关于个别选手在NOIP 2021中使用暴戾语言的处罚公告》事件”。\n正是为了这个目的，它是一个宣传材料。一篇鼓动选手用两个论点向CCF进攻的宣传材料。\n那么，这个目的足够崇高吗？经过反思了吗？\n我很想说，它是足够崇高的。但是，并不是这样。这个目的——要撤销对选手处罚的目的，是在得知这个消息的第一时刻，从下意识中产生出来的。这个目的是未经反思的，不崇高的，不能说服人的。这个目的为了实现自身，不得不把自身包装成另外的东西。那个东西就是竞赛的良性发展所需的公平正义和法治。\n一个被包装出来的事物，由于它要按原本目的对包装作裁剪，总是片面的。片面就在于，它无法站在现实的也即普遍的“竞赛良性发展”角度来考虑问题，而走向了法治之分析法条的片面性；它无法完整把握整件事中密切联系着的选手行为和处罚决定两个方面和它们的关系，而走向了只找处罚问题的片面性；它无法站在全部主体即学会成员和学生、家长、学校、作者本人等各方面考虑问题，而走向了忽视学会成员主体性并赋予它们任意假设的片面性。\n这三个片面性，注定了《公开信》与它的读者是冲突的，甚至是南辕北辙的。它的内容对于读者特别不彻底，因而不能通过说服人达到它所用于包装自己的公平正义和法治的现实结果，因而也不可能达到它本身要求的取消判罚的结果。\n在这里，我们将把这三个片面性所遮蔽之物全部展开，把理论讲得更彻底，届时一条真正维护竞赛的良性发展所需的公平正义和法治的道路会自然展现在我们面前。\n二、现实普遍的竞赛良性发展《公开信》的大致内容，是由两点不合规的事实推出整个处罚的不合规；《公告》的大致内容，则是援引指导性文件对选手进行批判。这两者的共同点，在于从规章、法条、文件这些被赋予了法的权威性的话语中寻找达成事实的条目。否则的话，后者就无需引用内容模糊的文件了。\n法治的形式，在于严格的依规依法办事。严格要求法的形式是法律运行和明确约束权力等功能的基础。在当前历史条件下，我国推进依法治国，学会也在推进依法治赛。因此，我当然主张，为了法治权威的大局，应当严格执行规定，采用有据可依的要求道歉和纪律处分等方式解决问题。我们知道，国家法律是社会的统治阶级依照形成它自身的规律，通过它们内部妥协产生的规则和共识，以国家机关这一表示集体意志的形式，依靠国家强制力（暴力机器）和社会权力关系的保障和严格执行的权威来运行的一种强制调节社会矛盾的框架。从法律中延伸出来的各级规则体系，自然也是依照某种集体组织的强制力来规范行为、调节矛盾的。从这个角度看，法治形式本身的局限性就很清楚了。那就是，法治是调节控制矛盾的工具，却不是解决矛盾的方法。例如，本次事件中，有取消判罚诉求的和学会决定矛盾的选手就从规章中寻找自己行事的依据。这当然是法治精神。但是，仅仅是诉诸法治，即诉诸调节矛盾的形式，而因此不考虑解决矛盾的办法，就不可能有进步而只能试图保持既有体系的不崩塌。用法律遮蔽问题，用压制矛盾取消解决矛盾的探索，这是资本主义的法权凌驾于现实的抽象的法治，不是追求解放人发展人的社会主义的法治。 一边用法律维系体系中人的基本生存，一边分析实践探索矛盾的解决之道，才是社会主义的法治精神。\n因此，当然地，在这个问题上争论CCF的解释力有多强，“扰乱竞赛秩序”的范围有多大，这些法条问题固然对法律的权威是重要的，但是它们却远远不能遮蔽对矛盾本身的探索。即对选手辱骂CCF这一现象背后各类深浅原因的追问和解决。我对这个追问和解决的详细见解，将在下文中展开。\n三、选手错误和惩罚的关系毫无疑问，这个惩罚是针对选手辱骂学会的反应，这一点将在下节得到验证。那些“这次xxx，下次yyy”的无前提的随意类比，都是建立在“辱骂学会本身并非惩罚的原因，而只是一个借口。”的猜想上。但实际情况并非如此，这一点也将在下节得到验证。当然，这样的猜想，是因为学会的处罚公告也和公开信一样，不得不用一般的社会主义精神文明建设和国务院办法来包装自己，因而也产生了片面性。被误解是不奇怪的。\n既然辱骂学会就是处罚的原因，那么要解决问题，就必须也搞清楚辱骂学会这一现象的原因。\n请想想吧，你现在是否因为这一事件更加气愤，更想辱骂学会了呢？\n许多人的答案是肯定的。那么，请再想想，你是否像本文那样，考虑过你的思维的片面性？\n你是否不加批判地接受网友说的，我们是在维护法治因而我们是完全正义的？\n你是否不加批判地接受网友说的，学会只是找借口，因而选手的行为和学会的做法无关，不需要深入研究如何解决选手的问题？甚至武断地宣判它无解？\n你是否不加批判地接受网友说的，学会就该机械般无条件严格按规则行动，收费或者出错就是倒行逆施？你是否把自己所听说的，抽象的“社会的黑暗”——如金钱至上、官官相护、私相授受、权力寻租，不加考察地代入了学会？你是否尝试考虑过学会成员的想法？\n如果答案为真，那很遗憾。因为你即使是在和自己切身相关的信息学竞赛问题上，也缺乏辩证和批判思维。当然，你是未成年人，在心理发育过程中这是难免的；又，有缺乏信息渠道等种种现实困难阻止你的进一步思考。但无论如何，这样的你对CCF的态度不是你自己的，而是从网友那里记忆来的，是一种网络模因，它在你不思考地吃瓜看乐子时日积月累地改变你的下意识，让你盲目从众，并使你在叛离时，在代码调不出想要宣泄情绪时将矛头对准你下意识中的那个强权——CCF。\n所看的言论是哪里来的呢？本来，那些言论所依附的事实都是明确而重要的——CCF收费、比赛故障、题目质量差、取消省队名额等等……在记忆中，每次也有确实分析提出建议的讨论。可是，我们怎么还在这里接受模因，看乐子呢？\n第一个原因，是我们不知道如何严肃面对竞赛问题；或者没有来自竞赛方面现实具体的生活压力。因而就不能从解决问题的角度严肃反思竞赛问题，反而不得不从暴戾语言那里享受一种虚假的反思和批判感。\n前者，即无法严肃面对竞赛问题，首先是由无法与教练群体、命题人、CCF、科协、教育部联系的无力感造成的；其次是由与他人或理想自我等反差导致的自卑感或无力感造成的；第三，是由于从各种渠道接受的对社会不公、体制问题等的抽象批判带来的焦虑，对现状和前途的完全迷茫导致的绝望和虚无；第四，就是特殊经历造成的心理创伤。解决这些问题，主要从建立CCF和选手有效联系和心理建设（关于更具体方法，另文详叙）角度考虑，解决更深层动因则需从社会主义原则考虑。\n后者，即我们能够不严肃对待竞赛的生活体验基础，就是信息竞赛体制本身所创设的临时的自由。在信息竞赛学习时，学生首先脱离了之前应试班集体的律令体系和集体关系，在学习中缺乏竞赛知识以外的交流，学习过程自治（因为信息竞赛教师往往不直接传授困难知识，需要大量自学），又在信息竞赛社区中受互联网的自由思想影响，很容易形成个人主义倾向。在个人主义倾向下，在社会上计算机行业的热潮下，许多学生容易认为自身在现在或者将来有自我生存的能力（因为当前临时的自学状态和对未来生活方式的小资产阶级理想），缺乏集体观念，缺乏现实人际交流，容易对互联网社区和互联网片段化信息产生认同。而OI社区就是一个互联网社区。如果没有引导，产生把互联网和现实对立起来，把OI社群和CCF或其它方面对立起来，二元对立，认为其中一种的极端化为理想，认同一个而厌恶另一个的思想也不奇怪。这样，就会产生一种完全抽象的批判的姿态，甚至在遇到挫折等后不与人交流以至于走向虚无或走极端。\n信息学竞赛提供自由的本意，在于充分发扬学生学习的主体性。要解决这个问题，也即激发学生的主体性。这方面，luogu的月赛日报社区管理，各种OJ、命题和开发社区，各种有具体内容的学术群和文化课群，是第一类经验，即在OI社群内部引导良性内容的经验。教师对教学的详细管理，对具体教学活动的参与，和学生的交流，是第二类经验。家庭教育是第三类经验。另外，有些问题迄今无良好方法，如文化课班级和竞赛的调和（很难既保持集体生活又避免心理压力导致竞赛和文化课的二元对立），以及如何在OI中建立集体体验。\n以上两者，是许多学生能够潜移默化接受跟风，辱骂CCF的主要原因。除此之外，对CCF的情绪化宣泄也有其它来源，这构成风气的起点。\n第一，部分家长、教练等因为收费、比赛故障、政策内容或政策变动等原因，由于利益受损，对CCF进行攻击。这种攻击有其原因，其存在是可以理解的，由于利益关系的复杂性和成年人思维方式的稳定，在计算机基础教育的内部恐怕无法解决，只能通过改革一定程度缓解以及引导无意义的情绪宣泄为有根据的批评。\n第二，部分退役学生（主要是大学生）因为仍然留在OI信息传播社群中，但又脱离了OI的切身利益。因此，他们由于没有深入了解或思考现状，或者个人性格等原因，在之前OI时期的下意识影响下，继续大量传播情绪化信息。由于这些信息直接流入学生互联网社群，也会造成重大影响。\n四、学会成员的主体性成年人是怎样的人？\n当然，我们有许多刻板印象。成熟冷静，思想复杂，社会经验丰富，工于心计，注重利益……这些标签，每个都可以贴在某时某刻的某些人身上。\n但首先，成年人是人。人有主体性，它本身就不能被符号所完整把握。成年人不是近似于所有刻板印象的总和。更不是我所想象的理想自我的反面。\n来看一段话吧：\n\n“如果是“赛”，就不让收费……不让收费呢，CCF是没钱的。……500名同学呢 ，你就要失去机会。……今年呢，就是⼀个多事之春，从冬令营开始到现在还没有完全停⽌……总有⼀种⼒量想把我们从正道上拨到邪路上去。……（⼀种态度是）坚信CCF是为⼤家考虑的，是为我们青少年考虑的……我们的宗旨是给那些学有余⼒的学⽣，有兴趣的学⽣，早⼀点接触计算机科学……也确实培养出了⼀批又⼀批的杰出的青年才俊。……（另⼀种态度是）遇到困难的时候顶不住，埋怨CCF。……我想没有第⼆个⼈像我这么热爱NOI，这么投⼊和为NOI着想。我不会把NOI断送掉，可是你们知道CCF的苦楚吗，你们知道我的苦楚吗？……后来我们是列在名单⾥头了，细节我不想跟你讲……有些事我也不便跟你们讲。……如果我实在达不到⽬的……我只能辞职⽽去，但绝不就范，绝对不……失掉真理，失掉正义和⾻⽓。”（《整形溢出》，第113-114页。这是一本出自OI学生之手的纪实文学，笔者引用它来说明部分学生心理。）\n\n想必参加过全国现场赛的同学们，都能感觉到这段讲话出自谁。参加过CTS2019的同学，可能还对此记忆犹新。当然，它出自NOI竞赛委员会主席杜子德。\n初听这段话，似乎口气很大，“我想没有第⼆个⼈像我这么热爱NOI，这么投⼊和为NOI着想。”又显得有些矫情，把辞职说成是“绝不就范，绝对不……失掉真理，失掉正义和⾻⽓。”还有些造作，“总有⼀种⼒量想把我们从正道上拨到邪路上去。”而且也有大言不惭之嫌，“坚信CCF是为⼤家考虑的，是为我们青少年考虑的……我们的宗旨是给那些学有余⼒的学⽣，有兴趣的学⽣，早⼀点接触计算机科学……也确实培养出了⼀批又⼀批的杰出的青年才俊。”个别对CCF的收费或者组织失误不满的同学，听到这样的话当然怨气更大，都当做形式主义假大空。有些习惯了骂CCF的同学，看到这位占用他们时间的有权力的老先生，也是付之一笑。有困难的同学和更多离开生活的同学，听到“苦楚”更是暗自腹诽。更有许多人把他的历史名言——例如“做干净的竞赛”之类拿来揶揄。\n当然，这是一位脾气倔强的老人，许多饱受争议的决定都是出自他手。例如被揶揄为“连坐”的扣省队名额处分——不过现在取消了。让我们来看看，这个省队处分是怎么一回事吧。\n这种“省组织出问题，选⼿承担后果”的处罚形式对CCF⽽⾔早已驾轻就熟。从2015年开始，每年都会有不同的省份由于代码提交不及时或出错，选⼿作弊，题⽬泄漏等原因被CCF加以扣减省队名额或提⾼NOIP分数线这类惩罚。……按照⼀位选⼿的⽐喻，这种惩罚⽅式就好⽐“某省⾼考收 卷出现失误造成批阅延迟，于是该省⼀本线提⾼五分”以及“某省某校考⽣作弊，该省扣除五千个⼀本名额”的⾏径。没有哪个信竞⽣对这种惩戒⽅式持正⾯看法，尤其因为这些选⼿很可能由于省队名额的缩减⽽⽆缘NOI。但即使这类“连坐”式的惩罚⼿段⼀向是被⼜口诛笔伐的对象，CCF也丝毫没有表现出要改进它的意思。有⼈将其描述为“⽆耻的⾏径重复多次，话题度就⼤⼤的降低，以后就会被认为是正常操作。……问题的核⼼始终在于⼀点：通过惩戒选⼿来间接对省组织施加压⼒的⽅式真的有⽤吗？如果有⽤，效果究竟多好？ ……我们不得不⾯对的⼀个事实是，⾃2015年起，在NOIP中出现违规现象的省份数量⼏乎每年都在增加，⽽同⼀个省份连续两年乃⾄三年出现问题的情况也并不罕见。单从结果来看的话，这些惩戒措施即使不说是毫⽆⽤处，也可以被视作收效甚微。这就意味着我们得从另⼀个⾓度来分析这个问题。由于信息学竞赛近年来的热度不断攀升，NOI系列赛事的参赛⼈数每⼀年都在增加。赛事规模越⼤，对组织⽅的要求也就越⾼；但部分省组织单位的能⼒显然暂时不⾜以应付越来越⾼的要求，所以在举办过程中出现种种状况的概率是相当不⼩的。另⼀⽅⾯，CCF并⾮⾏政单位，对省组织单位的管控能⼒相当有限。（事实上，省组织单位都是独⽴的法⼈代表机构。）在省赛区竞赛委员会的诸多职位中，CCF唯⼀有权⼒任免的职位仅限于特派员；⾄于省组织单位的整改，CCF则⼏乎没有任何插⼿的余地。因此，CCF能够采取的有效惩戒⽅式相当之少，除去“对特派员及省组织单位通报批评”之外，唯⼀能体现惩罚效果及决⼼的就只有对这个省的“切⾝利益”，也即省队名额和NOIP⼀等奖名额作扣减了。（⾄于这是选⼿们的切⾝利益还是省组织单位的切⾝利益，则另当别论。）这在很⼤程度上折射出了CCF对此的⽆能为⼒。 由于“连坐”式的惩罚⽅式，俞同学（引用者注：因为博客时间问题引起恐慌被禁赛一年的同学）⼴受争议的遭遇，正式⽐赛中出现的问题，以及其他种种因素，CCF在选⼿中的声誉于2018年底跌到了⼀个最低点。（《整形溢出》，第95-96页。）\n在2019年，仍然有这么一段评价：\nCCF采取的处罚⽅案也毫⽆新意可⾔：迟交数据的省组织单位及特派员被批评并罚款；作弊者被禁赛三年，所在的省份被扣减1个省队名额；江西省被扣减2个省队名额，并被责成进⼀步追究有关⼈员的法律责任。如果说这就是所谓新时代的开端的话，那它和过去⽐起来充其量就是换了层⽪⽽已。CCF及其下属省组织单位的能⼒仍旧令⼈不敢恭维，选⼿们的被动地位也没有任何改变。或许唯⼀的不同之处在于他们已经习惯了这种状况的⼀再发⽣。 （《整形溢出》，第128页。）\n诚然，CCF即使不能解决省组织的问题，作出一个对无辜学生不利的处罚也很不合理。因此，学生将作出这一决定的沉默的学会当作反面，就是不足为奇的了。一旦将其认定为反面，那么学会的一切行动都像是虚伪的。杜子德主席说“办干净的奥赛”，好像是沽名钓誉；学会处罚省组织，好像是推卸责任；学会取消连坐，好像是“广大学生的英勇斗争取得了胜利”，又好像是“和某些教练达成了不为人知的交易”；学会取消IOI环境，好像也是把CTSC2018的问题扣在改革和进步者的头上；学会编写大纲，好像是“伙同部分教练固化知识”，又好像是“搞应试教育化”；学会统一省选，好像是“急功近利，制造故障”；学会的三分之一限制，好像是“变相操纵省队”；学会的收费，好像是“吸血NOI学生补贴学会”，甚至“中饱私囊”。这些观点，有些不无道理，有些是捕风捉影，然而它们在许多学生眼中却都是来自于学会负面形象的结论。既然学会是负面形象，那么考虑学会的想法是一个禁忌，对学会非恶意的揣测，对真实意图的考察是不被思想允许的。学会的主体性，完全被它所扮演的负面形象遮蔽了。\n这种遮蔽的社会基础，首先在于学会和学生、家长之间信息和权力的不对称，学会和学校等方面之间的利益冲突。在当下的社会中，权力的不对称，信息的不对称，交流的缺乏，容易让人在他们下意识的范围内以最坏的恶意揣测其它主体。 对学生来说，学会是支配他们学习的一方。并且，由于青少年时期心理结构的不完善，容易简单化投射一个主观想象的本质，或者说，容易用主观理解的善恶等简单符号来认识他人。在信息不对称，在学会不主动宣传和接触选手，在接受了社群内刻板印象的宣传，在由于缺乏经验、畏惧权力等原因不愿意、不敢了解学会的情况下，学生很容易用负面形象来短路对学会的认识，这可以说是某种面对权力无能为力时的“自我保护”。这是社会普遍存在的问题，但通过严肃的交流是可以缓解的。\n可是，现在学生中这种负面形象完全遮蔽了真实的学会。我在这里问三个问题：\n取消连坐，更新语言，编写大纲，开发NOI Linux 2.0，统一省选环境……这些作为是如何进行的？工作推进中产生的问题，是否已有更好的解决方案而被CCF视而不见？换言之，对学会收钱不作为的批评在哪些程度上是具体的？\n有无任何证据，证明CCF NOI科学委员会的成员有不正当或者正当化的不良经济关系？换言之，做干净的奥赛在哪些程度上是具体的？\n总而言之，学会是否在NOI工作上具有大的保守性、拒绝意见、私心或者主观恶性等问题？用对待敌人的态度攻击学会是否总体上利于竞赛和教育的良性发展？\n第一个问题中提到的现象，无疑是学会NOI竞赛委员会领导教师、学生等共同完成的。\n如NOILinux，由赵启阳老师及其研究生等共同维护开发。对他们的批评是很多的，如系统内的漏洞和缺陷，如接受建议动作太慢、技术水平不足，如怀疑垄断NOI Linux课题、剥削研究生……但是，这些批评要怎样解决呢？当然，我们可以提出各种各样的解决方案，如增加技术能力更高的人手及时处理缺陷迅速更新系统，如吸收部分技术能力强且主动性强的现役、退役学生参与系统测试和维护并给予应当报酬，以至于以此改革机构……问题在于，对NOI科学委员会来说这些建议是否特别困难？我本人参与赵启阳老师和学生的许多联系工作，包括收集NOILinux 2.0建议等。NOILinux要找到高技术的，同时能够快速迭代和保证安全的开发团队，因为缺乏资金和业务的单一等原因，是困难的；在选手内部，其实技术开发能力也极为不足。大部分的项目都是个人项目，缺少协作和维护经验；小部分质量较高的项目，其有相当技术水平的人员分布也相当分散，且均有利益相关疑虑和学业等掣肘，要用学生团队等代替赵启阳老师大学课题团队，当前不够现实。清华算协、王逸松同学等的项目技术水平，调研能力和创新能力较好，但他们也是另起炉灶，和NOILinux平行开发，待功能成熟后再行借鉴、迭代，似乎比直接替代更适宜。至于省竞赛环境统一遇到的技术和非技术困难，也非调查研究不能解决。目前要发挥学生的主体性，一个是可以建设开源平台让学生的临时、局部想法能够记录，二是需要建立稳定广泛的宣传联系渠道，三是主动到各地产生实际问题的地方进行调研。这些也是我本人和一批同学近期和长期的重大工作。\n学会编写大纲、大纲辞典等整理竞赛知识体系，也是解决知识碎片化、不规范等长期问题的一个方案。但是，这项工作在和各校已有的教学体系，和大学、业界的要求和想法，和潜在出题人和毕业学生评判题目的标准，和知识的主力军现役学生的想法之间，会产生各种龃龉。这项工作中被批评的可能问题——如细化、僵化、固化、记背化知识体系，大纲在学界和题目张力之间的范畴，大纲指导命题的具体做法，如何保证OI自治的知识生产&#x2F;再生产不因此中断或者内卷化……这每一项问题都需对数学、算法、计算机科学的深入学习，对教学论的细致研究，对社会的科学的细致调研。还需要不断联系学会，联系各个实际参与编写的学生和教师。学会要在各方的差异中协调组织编写、审阅等一系列工作。这些也是我本人和一批同学参与的一项重大工作。\n在协调竞赛师生、承办方、省组织、政策、高校、业界、部委等各方面，推进竞赛改革的工作上，杜子德主席本人更做了大量突出的工作。他在CTS2019上的讲话，和之前许多看似歌功颂德的讲话（特别著名的比如“做干净的竞赛”），是真情流露。我曾参与一些史料收集工作，也了解到稍许过去的情况（不便透露细节），我个人是信任杜子德主席的，只是我之前也由于自己未能和他交流，对他的巨大影响力的畏惧等原因，不愿意去体会他的感情。我调查过杜子德主席的公开经济信息，也在工作中接触到一些熟悉历史的成员，我没有看到任何谋私利的迹象。当然，如果你把学会当作他的私心，那么在2014-2018年大量增加的竞赛收入事实上的确被运用在了学会的其它方面，在2018年左右每年达到上千万元。不过，在强基改革之后，CCF已经不再把竞赛作为主要盈余来源，转而用发展计算机相关产业等其它手段解决问题。例如说，各个“西西艾弗信息科技有限公司”都是在CCF秘书长交接的2021年成立的。这方面倒也可以深入研究，不过就不要写在一篇面向OIer的文章里了。当然，CCF应该向当事人公开某些被质疑收费不合理活动，例如在线竞赛、教师培训等的支出情况，并改革如疫情取消活动等状况下的的退款工作。\n我曾经见到许多选手抱怨某些省区竞赛活动舞弊嫌疑、乱收费、题目质量一言难尽等乱象。但是，当然地，推进统一各省竞赛环境是解决这些问题的主要方式，在这方面，CCF是必须起主要作用的。至于对CCF国级赛事的怀疑，以我个人参与相关活动的经验，除了“某些出题人可能平时太有名讲课太多，或者不遵守保密协议提前让人猜出出题人，导致有可能按人研究出题风格”，“严重疏忽和技术事故导致的出原题、原题重赛”这些问题外，其它明显影响竞赛公平的问题并未见过，这更加不是学会故意造成的。当然，偏题怪题原题等问题，以及比赛过程中的技术问题也是必须通过建立良好的命题管理、技术体系解决的。这其中具体的技术细节，仍然是我们需要参与的工作。\n学会NOI竞赛委员会和科学委员会的成员，吴文虎、尹宝林、杜子德、陈文光、王宏、赵启阳、蒋婷婷、韩文弢等每位老师，都是活生生的人，有自己的思想，都在信息学竞赛中做了多年工作。他们对教育的热爱，不谋私利的作风值得我们所有人学习。当然，老师们带有许多个人或者时代的特点，或者由于精力有限、需要保密、沟通不充分等，经常表现得固执、权威、忽视学生等等。作为信息学竞赛教育方面的同志，我们应该对具体的错误展开彻底的批评和自我批评；但是，批评和善恶评判完全是两样东西。完整了解现状和自己的能力后选择不同的工作方式，和喊口号批判现状空想一个没有内容的乌托邦更加是不同的东西。\n我们可以看到，学会的每项具体工作都有大量的具体问题，受到大量确实具体的批评。但是，学会并不是不关心结果，不能接受批评和改进工作，更不是不作为；主要受到的是历史惯性、交流缺乏和各种现实客观条件限制。这些并不能否认学会的贡献。更不能否认学会努力改善OI的作用和态度。\n总之，学会在NOI方面做了深入复杂的工作，我本人也是许多工作的参与者，深知工作遇到的现实困难，是不能想着打倒学会建立一个没有蓝图的新世界而解决的。既然学会支持我们的实践，既然学会不反对改革，既然学会NOI委员会的领导都是为OI多年无私奉献的讲道理的工作者，我们就没有理由把学会看作对立面，凭着想象和不完整的印象拒绝现实的实践的条件。我们只有在现存的体制中不断实践，在旧办法中创造和验证新办法，因为整体性解决问题的方法只能从具体每项工作的实践中，而不是几个理论家坐在书桌前对着思辨、概念和统计数据的空想中产生。 而要发扬学生的主体性，使建议和个别的经验能够推广，学会和学生的经常交流和通力合作是非常必要的。保护和发扬学生和教师的主体性，鼓励学生主动实践，组织学生，改善OI各方（特别是学生、弱校教师之间和他们与学会之间）的交流条件，是我本人在一个若干年的长时间内做OI工作的总任务。\n五、总结因此，我们不要说：\n\n只要立刻撤回一切以“程序中使用对CCF的侮辱性网络暴戾语言”为口实的无规判罚，公告说明情况，以维护竞赛之教育公平和公信，广大师生自然会和公义、和法治站在一起，完善教育规范，消除暴戾风气，支持学会加强学科竞赛的精神文明建设。\n\n那是谈条件，是针对敌人的口气，是针对守护腐朽制度的死硬的保守派既得利益者的口气。不是针对计算机基础教育建设者，我们最亲密同志的口气。更加不是针对一个无私者的口气。\n我们要说：\n\n为了信息学竞赛选手的道德教育和精神文明建设，为了选手的主动性和有益建议的及时传达，需要加强CCF和选手的联系，经常地和选手说明历史和现实，说明规则和想法，消除CCF和选手之间由于不交流造成的虚假对立形象。在这一基础上，严格执行规定以贯彻当前提出的依法治赛理念是有必要的。因此，需要考虑选手对自身错误的认识情况，重新考虑目前对禁赛、取消成绩等规定外惩罚措施的使用，后续完善规则对暴戾语言一致处理；并向选手充分宣传CCF做出决定的原因和依据，以及CCF的现实贡献。\n\n也许你会问，这不还是要取消竞赛方面的处罚吗？有什么区别？\n我的回答是：这是真正从竞赛良性发展出发，在更全面的角度分析得到的做法。正因为抱着真正经过反思的崇高的目的，才更能解释和解决下意识产生的冲动的目的。因为崇高的目的之所以崇高，就是因为它和下意识相容。\n也许你会问，这不是因为杜主席的个人想法而做的变通吗？这不是因为杜主席的一言堂造成的吗？这是否可以通过学会内部的民主，而不需要修改措辞来解决呢？\n我的回答是：不行。\n因为，之前的处罚决定其本身，就是一个民主决定。因为各个在学会为计算机教育事业奉献了多年的人，都很难接受一个被破口大骂的现实，很难接受一个仅靠条文的辩护。这里，不能认为缺乏规则条文所以无法处罚的法条道理必然是至高无上的。\n这是一个悲剧，一个来自于误解的悲剧。悲剧的种子早在CCF和选手社区间不存在联系的那一刻就埋下了。\n只有站在人的角度把理论讲彻底，抓住解决问题的根本——而不是把法条提高到比主体性更高的位置来指责——才能够消除这样的悲剧。\n我们不仅要做干净的奥赛，而且要研究如何做干净的奥赛，懂得如何做干净的奥赛，在未来不断做更干净的奥赛。\n而不是，讽刺着奥赛不够干净，然后想象该负责任的是谁。\n最后，让我们用《整形溢出》的一段话做结。\n是谁被调剂到和竞赛学科毫⽆关联的专业？是选⼿。是谁被弄丢代码，因为莫须有的原因被禁赛，由于同省考⽣的违规⾏为⽽错失省队名额？是选⼿。是谁被不明就⾥的⽹友斥责为所谓“权贵”？是选⼿。是谁整天为政策的变动所担⼼，唯恐⾃⼰的努⼒化为泡影？还是选⼿。可他们同时也是最缺乏话语权的⼀批⼈，在跟⾃⼰的命运息息相关的这些事务中，这些选⼿却⼏乎不能产⽣任何影响。他们唯⼀能采取的有效⼿段就是更加拼命地埋下头去学习各种知识，⼒图使⾃⼰在下⼀场的竞争中拔得头筹，⽽之后等着他们的还有更多的竞争。（《整形溢出》，第134-135页。）\n同学们。我们有主体性，我们有话语权，我们掌握知识，信息学归根究底是我们的。我们只不过是被困在二元对立的迷思和对世界与理想的刻板想象里，唯有实践，唯有学习，唯有反思，唯有交流，唯有创作，唯有开放，唯有严肃，唯有同情，才是通向未来的钥匙。\n","categories":["精华转载"]},{"title":"南航苏州附中建党百年朗诵活动","url":"/2021/09/12/2109poemsay/","content":"1.十人集体诗歌朗诵感谢以下参与人员参与录制：\n汤骏懿   姚远  顾天欣 崔可欣 曹艺舟 祝中翔\n杨海佳   沈思遥 王韬越 张翌晨\n导演：马泊宁 姚远\n拍摄+后期剪辑：马泊宁 陈星宇\n特别感谢后勤小组：何昊   金弈  蒯翔   顾俊贤   陈星宇\n视频播放 \n\n三连地址点击这里给作者给予支持：点击这里\n2.陈星宇讲故事主讲：陈星宇\n导演：马泊宁\n拍摄+后期剪辑：马泊宁 陈星宇\n特别感谢后勤小组： 张祉珺\n视频播放 \n\n三连地址点击这里给作者给予支持：点击这里\n3.张祉珺讲故事主讲：张祉珺\n导演：马泊宁\n拍摄+后期剪辑：马泊宁 陈星宇\n特别感谢后勤小组： 陈星宇\n视频播放 \n\n三连地址点击这里给作者给予支持：点击这里\n4.幕后花絮 \n\n点击这里给作者给予支持：点击这里\n感谢观看！\n","categories":["南航苏州附中校园活动"]},{"title":"2021南航苏州附中第45届校运会","url":"/2021/10/01/21sportsmeet/","content":" \n\n原地址：ClickHere\n","categories":["南航苏州附中校园活动"]},{"title":"转载：新冠大流行和数字资本主义的崛起（文/丹尼尔·科恩（Daniel Cohen））","url":"/2022/02/06/COVID-19-zbzydjq/","content":"新冠肺炎疫情的暴发，让面对面的交流接触成为了一种负担甚至是一种可怕的行为。为了让人们远离感染的风险，并防止大面积的感染造成的卫生系统的不堪重负，在许多国家，餐馆、咖啡馆、音乐厅和其他对繁荣的城市文明必不可少的文化设施，被关闭了长达一年之久。生活退回到家庭中，足不出户成为常态。\n　　疫情期间的封锁状态，依靠网络的在线工作场景，无需进入实体店的网上购物体验，在不冒险外出的情况下自娱自乐，最大的赢家是亚马逊、苹果和网飞等公司，它们的市值在新冠危机期间不断地飙升。\n　　事实上，这种所谓的数字资本主义恰恰依赖于减少实体互动和消除面对面会议的现实需要。新冠疫情使许多活动转向互联网的线上活动，例如，医疗问诊实现了远程在线服务。因而，疫情大流行让数字领域的巨头们获得了一个机会，得以对虚拟世界如何影响现实世界，进行一次全方位的实验。\n　　2021年1月20日，德国亚琛市，伯利恒医院的医生与亚琛大学医院的医生通过远程医疗系统，讨论针对新冠患者的治疗方案。\n　　要了解为什么数字经济与保护人们免受面对面互动的需要齐头并进，重读法国经济学家让·富雷斯蒂埃（Jean Fourastié）1948年的开创性著作《二十世纪的伟大希望》（The Great Hope of the Twentieth Century）会有所帮助。富雷斯蒂埃对未来世界进行了乐观的展望：在耕耘土壤的农业社会和与物质打交道的工业社会之后，服务社会中的人类最终将耕耘自己，教育、健康和休闲将成为新世界的核心。\n　　“第三产业文明将灿烂辉煌，一半或四分之三的人口将享受高等教育的优势。”富雷斯蒂埃写道，“在几代人之内，即使是低技能工作的主动性，以及交通工具和休闲活动的多样性，都会有利于人类的个人主义倾向。”\n　　因此，他得出的结论是，“这样的时代即将到来：历史已经进步到足以让人类合理地努力阐述新时代的哲学，并在一个不那么压抑的黑暗中努力实现戏剧性的诞生。机器要将人类从‘非生命体’就可自主完成的劳动中解放出来，把我们引向只有人类才能完成的工作：智力培养和道德提升。”\n　　转型成为一个“人性化”社会这一观点得到了诸多人的评论。在1930年代成为法国首位社会党总理的利昂·布卢姆（Léon Blum）就是其中之一，他在此书出版时写下了一段精彩且直指核心问题的评论。此书预测到了一个没有经济增长的世界。富雷斯蒂埃确信服务型社会不会受制于科技，而科技最终会让经济增长消失。如果一个人所能出售的商品是他与别人相处的时间，那么经济增长在理论上受限于人拥有的时间。\n　　疫情期间，亚马逊、网飞等公司成了大赢家。\n　　这就导致了经济学家所说的“鲍莫尔成本病”，这是由威廉·鲍莫尔（William J. Baumol）和威廉·鲍文（William G. Bowen）在1960年代创造的经济术语。无论是医疗、教育还是表演行业，相当于鲍莫尔提出的两部门非均衡增长模型中的停滞部门，这是服务行业显著特征，靠的是人的一对一或一对多的服务，劳动效率难以提高。\n　　如果没有数字技术，所有服务行业的从业人员都将缺少规模经济，从而无法让某个供应商接触到越来越多的客户。规模经济的概念，即企业可以在保持成本不变或只增加一点成本的情况下增加产量，是经济分析的基础。它让一家企业进入一个良性循环：客户群越大，其业务就越繁荣。否则，超过一定规模，公司就会陷入停滞。\n　　服务业为了获得最大的经济利益，需要能使产品受众群体数量级剧增的新兴科技。例如，电影和电视技术让比以往更多的观众能看到演员们的表演。\n　　我们花了很长时间，经过大量的反复试验，才找到了解决成本问题的方法。这也就是当下新兴的数字社会：当我们将人类个体的健康和欲望等肉体和精神的信息转化为数据集，人类就可以成为数字世界的一部分，在那里我们可以被算法管理，为了实现“效率”，每个人都必须成为可以被其他数据位处理的数据位。\n　　人工智能软件将为无限数量的客户提供治疗、咨询和娱乐，只要相关信息事先已经数字化。当我手腕上的手表分析我的生命体征时，算法可以为我的健康问题开发定制的解决方案。2013年的预言电影《她》描绘了一个拥有情感能力的人工智能，“她”有着女演员斯嘉丽·约翰逊（Scarlett Johansson）迷人的声音，同时和数百万人谈情说爱。这就是《数字化人类》（Homo digitalis）所发出的憧憬：一个从人体极限中解放出来的世界。\n　　正如富雷斯蒂埃预测的那样，人类是服务社会的核心，但为了满足当今对增长的永不枯竭的渴望，人类必须首先实现数字化。新冠大流行清楚地表明，一旦人们摆脱了面对面接触的必要性，在线实现增长是完全可能的。\n　　显然，最大的问题是，数字化治疗是否会比疾病本身更糟糕。机器人会取代人类并导致人类因此陷入贫困吗？工业流水线工作是否会通过脸书和网飞让位于思想的泰勒主义？让人类陷入一种思想上的“标准操作方法”？\n　　通过历史时间的不断轮回，数字世界正在取代工业世界，而工业世界的老问题也正在数字世界中重新浮出水面。因此，我们是否必须重蹈旧世界的每一个阶段，包括道德破产、金融危机和经济不安全，还是我们可以做得更好？\n　　到2022年，我们可能就会有答案了。\n　　（作者系巴黎经济学院校长、董事会主席，最近著有《不光彩的年代》）\n","categories":["精华转载"]},{"title":"不同的C++中求解A+B的方法","url":"/2021/08/12/a-b-problem/","content":"1.基础算法#include&lt;iostream&gt;using namespace std;int main()&#123; int a,b; cin&gt;&gt;a; cin&gt;&gt;b; cout&lt;&lt;a+b&lt;&lt;endl; return 0;&#125;\n\n#include &lt;stdio.h&gt;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d&quot;,a+b);    return 0;&#125;\n\n2.Link-Cut Tree#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;struct node &#123;    int data,rev,sum;    node *son[2],*pre;    bool judge();    bool isroot();    void pushdown();    void update();    void setson(node *child,int lr);&#125;lct[233];int top,a,b;node *getnew(int x)&#123;    node *now=lct+ ++top;    now-&gt;data=x;    now-&gt;pre=now-&gt;son[1]=now-&gt;son[0]=lct;    now-&gt;sum=0;    now-&gt;rev=0;    return now;&#125;bool node::judge()&#123;return pre-&gt;son[1]==this;&#125;bool node::isroot()&#123;    if(pre==lct)return true;    return !(pre-&gt;son[1]==this||pre-&gt;son[0]==this);&#125;void node::pushdown()&#123;    if(this==lct||!rev)return;    swap(son[0],son[1]);    son[0]-&gt;rev^=1;    son[1]-&gt;rev^=1;    rev=0;&#125;void node::update()&#123;sum=son[1]-&gt;sum+son[0]-&gt;sum+data;&#125;void node::setson(node *child,int lr)&#123;    this-&gt;pushdown();    child-&gt;pre=this;    son[lr]=child;    this-&gt;update();&#125;void rotate(node *now)&#123;    node *father=now-&gt;pre,*grandfa=father-&gt;pre;    if(!father-&gt;isroot()) grandfa-&gt;pushdown();    father-&gt;pushdown();now-&gt;pushdown();    int lr=now-&gt;judge();    father-&gt;setson(now-&gt;son[lr^1],lr);    if(father-&gt;isroot()) now-&gt;pre=grandfa;    else grandfa-&gt;setson(now,father-&gt;judge());    now-&gt;setson(father,lr^1);    father-&gt;update();now-&gt;update();    if(grandfa!=lct) grandfa-&gt;update();&#125;void splay(node *now)&#123;    if(now-&gt;isroot())return;    for(;!now-&gt;isroot();rotate(now))    if(!now-&gt;pre-&gt;isroot())    now-&gt;judge()==now-&gt;pre-&gt;judge()?rotate(now-&gt;pre):rotate(now);&#125;node *access(node *now)&#123;    node *last=lct;    for(;now!=lct;last=now,now=now-&gt;pre)    &#123;        splay(now);        now-&gt;setson(last,1);    &#125;    return last;&#125;void changeroot(node *now)&#123;    access(now)-&gt;rev^=1;    splay(now);&#125;void connect(node *x,node *y)&#123;    changeroot(x);    x-&gt;pre=y;    access(x);&#125;void cut(node *x,node *y)&#123;    changeroot(x);    access(y);    splay(x);    x-&gt;pushdown();    x-&gt;son[1]=y-&gt;pre=lct;    x-&gt;update();&#125;int query(node *x,node *y)&#123;    changeroot(x);    node *now=access(y);    return now-&gt;sum;&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    node *A=getnew(a);    node *B=getnew(b);        connect(A,B);        cut(A,B);        connect(A,B);    printf(&quot;%d\\n&quot;,query(A,B));     return 0;&#125;\n\n3.SFPA#include&lt;cstdio&gt;using namespace std;int n,m,a,b,op,head[200009],next[200009],dis[200009],len[200009],v[200009],l,r,team[200009],pd[100009],u,v1,e;int lt(int x,int y,int z)&#123;    op++,v[op]=y;    next[op]=head[x],head[x]=op,len[op]=z;&#125;int SPFA(int s,int f)//SPFA……&#123;    for(int i=1;i&lt;=200009;i++)&#123;dis[i]=999999999;&#125;    l=0,r=1,team[1]=s,pd[s]=1,dis[s]=0;    while(l!=r)    &#123;        l=(l+1)%90000,u=team[l],pd[u]=0,e=head[u];        while(e!=0)        &#123;            v1=v[e];            if(dis[v1]&gt;dis[u]+len[e])            &#123;                dis[v1]=dis[u]+len[e];                if(!pd[v1])                &#123;                    r=(r+1)%90000,                    team[r]=v1,                    pd[v1]=1;                &#125;            &#125;            e=next[e];        &#125;     &#125;    return dis[f];&#125;int main()&#123;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    lt(1,2,a);lt(2,3,b);    printf(&quot;%d&quot;,SPFA(1,3));    return 0;&#125;\n\n4.Floyed#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;long long n=3,a,b,dis[4][4];int main()&#123;    cin&gt;&gt;a&gt;&gt;b;    for(int i=1;i&lt;=n;i++)    &#123;        for(int j=1;j&lt;=n;j++)        &#123;            dis[i][j]=2147483647;        &#125;    &#125;    dis[1][2]=a,dis[2][3]=b;    for(int k=1;k&lt;=n;k++)    &#123;        for(int i=1;i&lt;=n;i++)        &#123;            for(int j=1;j&lt;=n;j++)            &#123;                dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j]);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[1][3];&#125;\n\n5.递归算法#include&lt;iostream&gt;using namespace std;long long a,b,c;long long dg(long long a)&#123;    if(a&lt;=5)&#123;return a;&#125;    return (dg(a/2)+dg(a-a/2));&#125;int main()&#123;    cin&gt;&gt;a&gt;&gt;b;    c=dg(a)+dg(b);    cout&lt;&lt;c;&#125;\n\n6.高精度计算#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123;    char a1[1000],b1[1000];      int a[1000]=&#123;0&#125;,b[1000]=&#123;0&#125;,c[1000]=&#123;0&#125;,la,lb,lc,i,x;      cin&gt;&gt;a1&gt;&gt;b1;      la=strlen(a1);      lb=strlen(b1);      for(i=0;i&lt;=la-1;i++)&#123;a[la-i]=a1[i]-48;&#125;    for(i=0;i&lt;=lb-1;i++)&#123;b[lb-i]=b1[i]-48;&#125;      lc=1,x=0;    while(lc&lt;=la||lc&lt;=lb)&#123;c[lc]=a[lc]+b[lc]+x,x=c[lc]/10,c[lc]%=10,lc++;&#125;    c[lc]=x;    if(c[lc]==0)&#123;lc--;&#125;    for(i=lc;i&gt;=1;i--)&#123;cout&lt;&lt;c[i];&#125;    cout&lt;&lt;endl;    return 0;&#125;\n\n7.压位高精#include &lt;cstdio&gt;  #include &lt;cstring&gt;  #include &lt;cstdlib&gt;  #include &lt;iostream&gt;  #define p 8#define carry 100000000using namespace std;  const int Maxn=50001;  char s1[Maxn],s2[Maxn];  int a[Maxn],b[Maxn],ans[Maxn];  int change(char s[],int n[])   &#123;      char temp[Maxn];       int len=strlen(s+1),cur=0;      while(len/p)    &#123;          strncpy(temp,s+len-p+1,p);        n[++cur]=atoi(temp);         len-=p;    &#125;      if(len)    &#123;        memset(temp,0,sizeof(temp));          strncpy(temp,s+1,len);          n[++cur]=atoi(temp);       &#125;      return cur;&#125;  int add(int a[],int b[],int c[],int l1,int l2)  &#123;      int x=0,l3=max(l1,l2);      for(int i=1;i&lt;=l3;i++)    &#123;          c[i]=a[i]+b[i]+x;          x=c[i]/carry;        c[i]%=carry;      &#125;      while(x&gt;0)&#123;c[++l3]=x%10;x/=10;&#125;      return l3;&#125;  void print(int a[],int len)  &#123;       printf(&quot;%d&quot;,a[len]);    for(int i=len-1;i&gt;=1;i--)printf(&quot;%0*d&quot;,p,a[i]);    printf(&quot;\\n&quot;);  &#125;  int main()  &#123;    scanf(&quot;%s%s&quot;,s1+1,s2+1);    int la=change(s1,a);    int lb=change(s2,b);    int len=add(a,b,ans,la,lb);        print(ans,len);&#125;  \n\n8.树状数组#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int lowbit(int a)&#123;    return a&amp;(-a);&#125;int main()&#123;    int n=2,m=1;    int ans[m+1];    int a[n+1],c[n+1],s[n+1];    int o=0;    memset(c,0,sizeof(c));    s[0]=0;    for(int i=1;i&lt;=n;i++)    &#123;        cin&gt;&gt;a[i];        s[i]=s[i-1]+a[i];        c[i]=s[i]-s[i-lowbit(i)];//树状数组创建前缀和优化    &#125;    for(int i=1;i&lt;=m;i++)    &#123;        int q=2;        if(q==1)        &#123;           int x,y;           cin&gt;&gt;x&gt;&gt;y;           int j=x;           while(j&lt;=n)           &#123;               c[j]+=y;               j+=lowbit(j);           &#125;        &#125;        else        &#123;            int x=1,y=2;            int s1=0,s2=0,p=x-1;            while(p&gt;0)            &#123;                s1+=c[p];                p-=lowbit(p);            &#125;            p=y;            while(p&gt;0)            &#123;                s2+=c[p];                p-=lowbit(p);            &#125;                o++;            ans[o]=s2-s1;        &#125;    &#125;    for(int i=1;i&lt;=o;i++)        cout&lt;&lt;ans[i]&lt;&lt;endl;    return 0;&#125;\n\n9.粗暴模拟人工运算#include &lt;iostream&gt; #include &lt;cmath&gt;using namespace std;int fu=1,f=1,a,b,c=0;int main()&#123;    cin&gt;&gt;a&gt;&gt;b;    if(a&lt;0&amp;&amp;b&gt;0)fu=2;    if(a&gt;0&amp;&amp;b&lt;0)fu=3;    if(a&lt;0&amp;&amp;b&lt;0)f=-1;    if(a==0)&#123;cout&lt;&lt;b;return 0;&#125;    if(b==0)&#123;cout&lt;&lt;a;return 0;&#125;     a=abs(a);    b=abs(b);    if(a&gt;b&amp;&amp;fu==3)f=1;    if(b&gt;a&amp;&amp;fu==3)f=-1;    if(b&gt;a&amp;&amp;fu==2)f=1;    if(b&lt;a&amp;&amp;fu==2)f=-1;    if(fu==1)c=a+b;    if(fu&gt;1)c=max(a,b)-min(a,b);    c*=f;    cout&lt;&lt;c;    return 0;&#125;\n\n10.Dijkstra+STL的优先队列优化#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;cctype&gt;#include &lt;climits&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;ctime&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;const int N=405;struct Edge &#123;    int v,w;&#125;;vector&lt;Edge&gt; edge[N*N];int n;int dis[N*N];bool vis[N*N];struct cmp &#123;    bool operator()(int a,int b) &#123;        return dis[a]&gt;dis[b];    &#125;&#125;;int Dijkstra(int start,int end)&#123;    priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; dijQue;    memset(dis,-1,sizeof(dis));    memset(vis,0,sizeof(vis));    dijQue.push(start);    dis[start]=0;    while(!dijQue.empty()) &#123;        int u=dijQue.top();        dijQue.pop();        vis[u]=0;        if(u==end)            break;        for(int i=0; i&lt;edge[u].size(); i++) &#123;            int v=edge[u][i].v;            if(dis[v]==-1 || dis[v]&gt;dis[u]+edge[u][i].w) &#123;                dis[v]=dis[u]+edge[u][i].w;                if(!vis[v]) &#123;                    vis[v]=true;                    dijQue.push(v);                &#125;            &#125;        &#125;    &#125;    return dis[end];&#125;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    Edge Qpush;        Qpush.v=1;    Qpush.w=a;    edge[0].push_back(Qpush);        Qpush.v=2;    Qpush.w=b;    edge[1].push_back(Qpush);        printf(&quot;%d&quot;,Dijkstra(0,2));    return 0;&#125;\n\n11.分治算法（二分法）#include&lt;cstdio&gt;using namespace std;int a,b,c; int main()&#123;long long l=-int(1e9)&lt;&lt;1,r=int(1e9)&lt;&lt;1;     scanf(&quot;%d%d&quot;,&amp;a,&amp;b);     while(r-l&gt;1)&#123;c=(l+r)&gt;&gt;1;         if(c-b&lt;a)l=c;         else if(c-b&gt;a)r=c;             else return printf(&quot;%d\\n&quot;,c),0;     &#125;if(l!=r)return printf(&quot;%d\\n&quot;,r),0; &#125;\n\n12.位运算#include &lt;cstdio&gt;int m, n;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);    int u = m &amp; n;    int v = m ^ n;    while (u) &#123;        int s = v;        int t = u &lt;&lt; 1;        u = s &amp; t;        v = s ^ t;    &#125;    printf(&quot;%d\\n&quot;, v);&#125;\n\n13.线段树#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;iostream&gt;using namespace std;struct node&#123;    int val,l,r;&#125;;node t[5];int a[5],f[5];int n,m;void init()&#123;    for(int i=1;i&lt;=2;i++)&#123;        scanf(&quot;%d&quot;,&amp;a[i]);    &#125;&#125;void build(int l,int r,int node)&#123;    t[node].l=l;t[node].r=r;t[node].val=0;    if(l==r)&#123;        f[l]=node;        t[node].val=a[l];        return;    &#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,node*2);    build(mid+1,r,node*2+1);    t[node].val=t[node*2].val+t[node*2+1].val;&#125;void update(int node)&#123;    if(node==1)return;    int fa=node&gt;&gt;1;    t[fa].val=t[fa*2].val+t[fa*2+1].val;    update(fa);&#125;int find(int l,int r,int node)&#123;    if(t[node].l==l&amp;&amp;t[node].r==r)&#123;        return t[node].val;    &#125;    int sum=0;    int lc=node*2;int rc=lc+1;    if(t[lc].r&gt;=l)&#123;        if(t[lc].r&gt;=r)&#123;            sum+=find(l,r,lc);        &#125;        else&#123;            sum+=find(l,t[lc].r,lc);        &#125;    &#125;    if(t[rc].l&lt;=r)&#123;        if(t[rc].l&lt;=l)&#123;            sum+=find(l,r,rc);        &#125;        else&#123;            sum+=find(t[rc].l,r,rc);        &#125;    &#125;    return sum;&#125;int main()&#123;    init();    build(1,2,1);    printf(&quot;%d&quot;,find(1,2,1));&#125;\n\n14.快读#include &lt;cstdio&gt;int read()&#123;    int f=1,x=0;char ch=getchar();    while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;)f=-1;ch=getchar();&#125;    while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;x=x*10+ch-&#x27;0&#x27;;ch=getchar();&#125;    return f*x;&#125;int main()&#123;    printf(&quot;%d&quot;,read()+read());    return 0;&#125;\n","categories":["编程算法"],"tags":["computer,cpp"]},{"title":"C语言中跨文件的全局变量","url":"/2021/08/19/c-global-variables-in-multiple-files/","content":"首先看一段代码\nfunc.c\nint buf = 0;void func() &#123;  buf = 2;  /*Do something else*/&#125;\n\nmain.c\n# include &lt;stdio.h&gt;int buf;void func();int main() &#123;  buf = 1;  func();  printf(&quot;%d\\n&quot;, buf);  return 0;&#125;\n\n编译两个文件，输出的结果是怎样的呢？一眼看上去，可能会输出1，因为两个全局变量buf在不同文件中，又没有extern声明，显然是两个嘛。然而实际上它的运行结果却是2，这说明了这两个文件中引用到的其实是一个变量！\n这是为什么呢？原因是在编译时，C语言编译器将全局符号标记为strong和weak两类：\n函数和初始化的全局符号被标记为strong未初始化的全局符号被标记为weak连接时，连接器对多重定义的全局符号的解析原则如下：\n同一个符号不允许有多个strong定义；假如一个符号有一个strong定义和多个weak定义，那么采用该符号的strong定义；假如一个符号有多个weak定义，那么选取任意一个weak定义由于两个变量一个初始化了，一个没有初始化，所以一个是strong，一个是weak，所以连接器在符号解析时会把他们当成一个。\n如果我们把main.c中的buf也初始化了：\n# include &lt;stdio.h&gt;int buf = 0;void func();int main() &#123;  buf = 1;  func();  printf(&quot;%d\\n&quot;, buf);  return 0;&#125;\n\n再次编译就会发现\nduplicate symbol _buf in:    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZ87C6g.o    /var/folders/44/_cc501qx1jd1p5bfrjbk6b100000gn/T//ccZlES8n.old: 1 duplicate symbol for architecture x86_64collect2: ld returned 1 exit status\n\n这是因为两个全局变量都是strong的。\n","categories":["编程算法"],"tags":["computer,cpp"]},{"title":"从零开始C++——1","url":"/2021/08/26/cpp-begin-1/","content":"本文为原创文章，请转载时一定要注明作者：Bill Ma，网址https://billma.top\nThis blog is licensed under CC BY-NC-SA 4.0 unless stating additionally.\n\n一.准备工作看到这篇文章，说明你已经有了这个想法。那么，想要编程，总得要一个软件吧。如果你已经有一定的其他的语言基础，知道了编程软件的基本架构，建议你使用Microsoft的Visual Studio Code。如果你对编程一无所知，你可以使用小白软件Dev C++。\n点此下载DevC++\n点此下载MicrosoftVisualStudioCode\n本教程就以Dev C++为实例。\n1.启动界面启动界面，发现该界面分为四部分。上面是菜单栏和一堆按钮，右侧是一块大空白，左侧是“项目管理，查看类和调试”，下面是调试。\n\n接下来，按Ctrl+N，新建一个源代码。\n\n2.了解C++基本构造a.头文件头文件以 #include 开头。你在C++中所用到的所有函数都包含在各种各样的头文件中。比如说，最常见的输出函数printf()就在cstdio头文件中。再比如说，输入输出流cin和cout就在iostream中。如果你懒得记哪个函数在哪个函数库头文件里，你可以偷懒，只写一个：\n#include &lt;bits/stdc++.h&gt;\n\n这个头文件包含了C++大多数常用头文件。你写了这个就不用再写其它头文件了。但是注意，bits&#x2F;stdc++.h不包含所有头文件。比如说，比较常用的#include&lt;conio.h&gt;和#include &lt;windows.h&gt;就不在其中。\nb.函数函数有很多种，现在讲为时过早，日后再议。现在要知道的是主函数。主函数是C++代码的核心部分。C++所有代码都包含在主函数内。在主函数的最后，需要以return 0;为结尾。\nc.变量C++提供了许多变量。其中包含\n//整形变量(存放整数)int //浮点型函数float//单精度double//双精度//字符/字符串char//单个字符string//字符串wchar_t//单个宽字符，即非英文或数字wstring//宽字符串\n\n注意，上图的&#x2F;&#x2F;代表注释，不参与主要运算。\n变量声明方法：\nint a;char b;string c;\n\n哦，差点忘了，你想要运行你的程序，只需要按F11或者选择编译即可。\n2.你的第一个程序先从一个例子开始：\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout&lt;&lt;&quot;Hello World!&quot;&lt;&lt;endl;    return 0;&#125;\n\n1.标准输入输出```包含了cout,cin,endl等。cout表示输出，cin表示输入，endl是换行符。C++将键盘作为输入设备，屏幕等为输出设备。而且，C++将你输入的和输出的当作一个流，比如说以下两句话是等价的：```C++cout&lt;&lt;&quot;helloworld!&quot;&lt;&lt;endl;cout&lt;&lt;&quot;hello&quot;&lt;&lt;&quot;world!&quot;&lt;&lt;endl;\n\n因为C++是输出流，所以先把hello流出来再把world流出来，和流出来helloworld是一样的。下面是cout和cin的具体用法：\nint a,b,c,dcin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;//这里没有endlcout&lt;&lt;a&lt;&lt;b&lt;&lt;c&lt;&lt;endl&lt;&lt;d&lt;&lt;endl;\n\n输入： \n32 44 23 23\n\n输出：\n32442323\n\n为什么a和b和c中间没有空格呢？很简单，因为你没有加空格啊。a和b都是数字，没有空格。\n那么，下面代码会输出什么呢？\ncout&lt;&lt;12&lt;&lt;34&lt;&lt;56&lt;&lt;endl;cout&lt;&lt;  12  &lt;&lt;  34  &lt;&lt;  56  &lt;&lt;endl;cout&lt;&lt;&quot;12&quot;&lt;&lt;&quot;34&quot;&lt;&lt;&quot;56&quot;&lt;&lt;endl;cout&lt;&lt;&quot;  12  &quot;&lt;&lt;&quot;  34  &quot;&lt;&lt;&quot;  56  &quot;&lt;&lt;endl;\n\n输出：\n12345612345612345612    34    56  \n\n有人会问，为什么2也是123456？因为在每两个 &lt;&lt; 中，只能有一个量（变量和常量），你用双引号引起来的叫字符串，只有在变量或者字符串里的才能被输出。\n3.你的第二个程序这个程序要稍微复杂一点了：\n#include&lt;iostream&gt;using namespace std;int main()&#123;    int a;    cin&gt;&gt;a;    a=a+1;    cout&lt;&lt;a;    return 0;&#125;\n\n输入：1，输出：2\n这个a&#x3D;a+1不是非法语句，而是正确的。这句话翻译成中文就是：a在你原来a的基础上再+1\n4.你的第三个程序#include &lt;iostream&gt;using namespace std;int main()&#123;    for(int a=1;a&lt;=7;a++)    &#123;        if(a==1||a&gt;=6)        &#123;            cout&lt;&lt;&quot;1&quot;&lt;&lt;endl;        &#125;        else if(a&lt;=3)        &#123;            cout&lt;&lt;&quot;2&quot;&lt;&lt;endl;        &#125;        else if(a&lt;5&amp;&amp;a&gt;3)        &#123;            cout&lt;&lt;&quot;3&quot;&lt;&lt;endl;        &#125;        else         &#123;            cout&lt;&lt;&quot;4&quot;&lt;&lt;endl;        &#125;    &#125;&#125;\n\n输出：\n1223311\n\n什么意思呢？首先来看for(int a=1;a&lt;=7;a++),这句话意思是a从1开始技术\n未完待续……","tags":["teach，computer，cpp"]},{"title":"C++ 中如何处理错误和异常？","url":"/2021/08/26/cpp-constructor-exception/","content":"1.前言用C++写代码的时候总是避免不了处理错误，一般来说有两种方式，通过函数的返回值或者抛出异常。C语言的错误处理一律是通过函数的返回值来判断的，一般是返回0、NULL或者-1表示错误，或者直接返回错误代码，具体是哪种方式没有统一的规定，各种API也各有各的偏好。譬如fopen函数，当成功时返回文件指针，失败时返回NULL，而POSIX标准的open函数则在成功时返回0或者正数，失败时返回-1，然后需要再通过全局变量errno来判断具体错误是什么，配套的还有一系列perror、strerror这样的函数。\n2.C++的错误处理方式C++号称向下兼容C语言，于是就将C语言通过返回值的错误处理方式也搬了进来。但C++最大的不同是引入了异常机制，可以用throw产生一个异常，并通过try和catch来捕获。于是就混乱了，到底是什么时候使用返回值表示错误，什么时候使用异常呢？首先简单谈论一下异常和返回值的特点。\n异常的优点错误信息丰富，便于获得错误现场\n代码相对简短，不需要判断每个函数的返回值\n异常的缺点使控制流变得复杂，难以追踪\n开销相对较大\n返回值的优点性能开销相对小\n避免定义异常类\n返回值的缺点程序员经常「忘记」处理错误返回值\n每个可能产生错误的函数在调用后都需要判断是否有错误\n与「真正的」返回值混用，需要规定一个错误代码（通常是0、-1或NULL）使用异常还是返回值\n我的观点是，用异常来表示真正的、而且不太可能发生的错误。所谓不太可能发生的错误，指的是真正难以预料，但发生了却又不得不单独处理的，譬如内存耗尽、读文件发生故障。而在一个字符串中查找一个子串，如果没有找到显然应该是用一个特殊的返回值（如-1），而不应该抛出一个异常。\n一句话来概况就是不要用异常代替正常的控制流，只有当程序真的「不正常」的时候，才使用异常。反过来说，当程序真正发生错误了，一定要使用异常而不是返回一个错误代码，因为错误代码总是倾向于被忽略。如果要保证一个以返回值来表示错误代码的函数的错误正确地向上传递，需要在每个调用了可能产生错误的函数后面都判断一下是否发生了错误，一旦发生了不可解决的错误，就要终止当前函数（并释放当前函数申请的资源），然后向上传递错误。这样一来错误处理代码会被重复地写好几遍，十分冗杂，譬如下面代码：\nint func(int n) &#123;  int fd = open(&quot;path/to/file&quot;, O_RDONLY);  if (fd == -1) &#123;     return ERROR_OPEN;  &#125;  int* array = new[n];  int err;  err = do_something(fd, array);  if (err != SUCCESS) &#123;     delete[] array;     return err;  &#125;  err = do_other_thing();  if (err != SUCCESS) &#123;     delete[] array;     return err;  &#125;  err = do_more_thing();  if (err != SUCCESS) &#123;     delete[] array;     return err;  &#125;  delete[] array;  return SUCCESS;&#125;\n\n对使用异常容易增加函数出口的指控其实是不成立的，因为即使使用返回值，这些出口也是免不了的，除非程序员有意或无意忽略掉，但异常是不可忽略的。如果你认为可以把判断错误的if语句缩写到一行使代码变得「更清晰」，那么我只能说是自欺欺人。\n有些错误几乎总是可以被立即恢复（譬如前面所说的查找一个字符串不存在的子串，甚至都不能说这是一个「错误」），而且返回值本身就传递一定信息，就不需要使用异常了。\n鉴于C++没有统一的ABI，并不建议在模块的接口上使用异常。如果要使用，就要把可能曝露给用户的异常全部声明出来，不要把其他类型的异常丢给用户去处理，尤其是内部状态——模块的使用者通常也不会关心模块内部具体是哪条语句发生错误了。\n3.构造函数中的错误有一个相当实际的问题是，如何处理构造函数的错误？我们都知道构造函数是没有返回值的，怎么办呢？通常有三种常见的处理方法，标记错误状态、使用一个额外的initialize函数来初始化，或者直接抛出异常。\n合格的C++程序员都知道C++的析构函数中不应该抛出异常，一旦析构函数中的异常没有被捕获，整个程序都要被中止掉。于是许多人就对在构造函数中抛出异常也产生了对等的恐惧，宁可使用一个额外的初始化函数在里面初始化对象的状态并抛出异常（或者返回错误代码）。这样做违背了对象产生和初始化要在一起的原则，强迫用户记住调用一个额外的初始化函数，一旦没有调用直接使用了其他函数，其行为很可能是未定义的。\n使用初始化函数的惟一好处可能是避免了手动释放资源（释放资源的操作交给析构函数来做），因为C++的一个特点是构造函数抛出异常以后析构函数是不会被调用的，所以如果你在构造函数里面申请了内存或者打开了资源，需要在异常产生时关闭。但想想看其实并不能完全避免，因为有些资源可能是要在可能产生错误的函数调用过后才被申请的，还是无法完全避免手工的释放。\n标记错误状态也是一种常见的形式，譬如STL中的ifstream类，当构造时传入一个无法访问的文件作为参数，它不会返回任何错误，而是标记的内部状态为不可用，用户需要手工通过is_open()函数来判断是否打开成功了。同时它还有good()、fail()两个函数，同时也重载了bool类型转换运算符用于在if语句中判断。标记状态的方法在实践中相当丑陋，因为在使用前总是需要判断它是否「真的创建成功了」。\n最直接的方法还是在构造函数中抛出异常，它并不会向析构函数中抛出异常那样有严重的后果，只是需要注意的是抛出异常以后对象没有被创建成功，析构函数也不会被调用，所以应该自行把申请的资源全部都释放掉。\n4.如何在构造函数中捕获异常构造函数与普通函数有一个很不一样特性，就是构造函数可以有初始化列表，例如下面的代码：\nclass B &#123; public:  B(int val) : val_(val * val) &#123;  &#125; private:  int val_;&#125;;class A &#123; public:  A(int val) : b_(val) &#123;    a_ = val;  &#125; private:  int a_;  B b_;&#125;;\n\n以上的代码中A的构造函数的函数体的语句在执行之前会先调用B的构造函数，这时候问题在于，如果B的构造函数抛出了异常，A该如何捕获呢？一个迂回的做法是在A中把B的实例声明为指针，在构造函数和析构函数中分别创建和删除，这样就能捕获到异常了。不过，实际上是有更简单的做法的。下面我要介绍一个C++的很不常见的语法：函数作用域级别的异常捕获。\nclass B &#123; public:  B(int val) : val_(val * val) &#123;    throw runtime_error(&quot;wtf from B&quot;);  &#125; private:  int val_;&#125;;class A &#123; public:  A(int val) try : b_(val) &#123;    a_ = val;  &#125; catch (runtime_error&amp; e) &#123;    cerr &lt;&lt; e.what() &lt;&lt; endl;    throw runtime_error(&quot;wtf from A&quot;);  &#125; private:  int a_;  B b_;&#125;;\n\n注意上面A的构造函数，在参数列表后和初始化列表前增加了try关键字，然后构造函数就被分割为了两部分，前面是初始化，后面是初始化时的错误处理。需要指出的是，catch块里面捕获到的异常不能被忽略，即catch块中必须有一个throw语句重新抛出异常，如果没有，则默认会将原来捕获到的异常重新抛出，这和一般的行为是不同的。例如下面代码运行可以发现A会将捕获到的异常原封不动抛出：\nclass A &#123; public:  A(int val) try : b_(val) &#123;    a_ = val;  &#125; catch (runtime_error&amp; e) &#123;    cerr &lt;&lt; e.what() &lt;&lt; endl;  &#125; private:  int a_;  B b_;&#125;;\n\n这种语法是C++的标准，而且目前已经被所有的主流C++编译器支持（VS2010、g++ 4.2、clang 3.1），所以几乎不存在兼容性问题，大可放心使用。\n5.其他语言中的错误处理Java倾向于大量使用异常，而且还把异常分为了两类分别是检查型异常(Checked Exception)和非检查型异常(Unchecked Exception)，检查型异常就是java.lang.Exception的子类，用于报告需要检查的错误，也就是正常的业务逻辑，错误主要是由用户产生的，方便恢复或给出提示，譬如打开不存在的文件。而非检查型异常则是真正的系统异常，通常由软件缺陷导致，如数组下标越界、错误的类型转换等，这类异常继承于java.lang.RuntimeException或java.lang.Error。\nPython和Java一样也倾向于使用异常，并不一定真的发生故障才抛出异常，譬如字符串转换为整数，如果字符串不合法，Python会抛出一个ValueError异常。甚至Python的迭代器在调用next()时没有更多的结果时会抛出StopIteration 异常。这是典型的用异常来处理正常控制流的方法，在Python中被广泛使用。按照优秀C++代码的标准来看，这是典型的对异常的滥用，既复杂又有额外开销，不推荐使用，但在Python中这是一个广泛遵循的约定。\n相较于Java和Python，Go的错误处理是另一个极端，Go语言则根本没有异常的概念，而是普遍采用返回值的方式来表示错误，同时还提供了panic和recover语法。由于Go有多返回值的特性，避免了错误代码占用返回结果的弊端，所以你可以经常看到函数的最后一个返回值是error类型。由于总是用返回值传递错误，你可以看到Go代码中耦合了大量的错误处理，几乎再每条函数调用语句之后都有一个判断错误是否发生的语句。panic和recover机制十分类似于异常，程序在遇到panic时会一层一层退出调用栈，直到遇到recover。不过recover只在defer中定义，相当于一个函数只有一个recover，而且被recover恢复后会回到错误发生处继续向下执行代码。Go语言倾向于把一般错误都作为返回值传递，除非是非常可怕的、除了重置状态几乎无法恢复错误才会被panic语句抛出。\nGo语言的recover机制和异常比起来，反倒更像Visual Basic语言中的On Error GoTo label及Resume语法。这是一种非结构化的错误处理方式，具体是当声明有On Error GoTo label的函数发生错误以后，会调转到对应的行号，如果再遇到了Resume语句就会返回发生错误的语句后面的一条继续执行，例如下面这段代码：\nSub ErrorDemo    On Error GoTo ErrorHandler    Dim a as Integer    a = 1/0 &#x27; An error occurs.    Print a &#x27; Go back here    Exit SubErrorHandler:    &#x27; Code that handles errors.    ResumeEnd Sub\n\nVisual Basic中还有On Error Resume Next这样的万能错误处理语句，即遇到错误以后直接忽略并继续执行，这是一种非常危险而且不负责任的做法，但却可以在早期的Visual Basic代码中到处看到。事实上用返回值传递错误代码的时候许多人也并不处理而是直接忽略，这跟On Error Resume Next本质上没有什么区别，却比On Error Resume Next危害更大——因为On Error Resume Next至少还有个标记说明「老子就是这么不负责任」，但忽略错误返回值就难以被一眼发现了。\n","categories":["编程算法"]},{"title":"C++中fstream的用法","url":"/2021/08/04/cpp-fstream/","content":"写在前面：啥是fstreamofstream是从内存到硬盘，ifstream是从硬盘到内存，其实所谓的流缓冲就是内存空间;\n在C++中，有一个stream这个类，所有的I&#x2F;O都以这个“流”类为基础的，包括我们要认识的文件I&#x2F;O，stream这个类有两个重要的运算符：\n1、插入器(&lt;&lt;) 向流输出数据比如说系统有一个默认的标准输出流(cout)，一般情况下就是指的显示器，所以，cout&lt;&lt;“Write Stdout”&lt;&lt;’\\n’;就表示把字符串”Write Stdout”和换行字符(‘\\n’)输出到标准输出流。\n2、析取器(&gt;&gt;) 从流中输入数据比如说系统有一个默认的标准输入流(cin)，一般情况下就是指的键盘，所以，cin&gt;&gt;x;就表示从标准输入流中读取一个指定类型(即变量x的类型)的数据。\n在C++中，对文件的操作是通过stream的子类fstream(file stream)来实现的，所以，要用这种方式操作文件，就必须加入头文件fstream.h。下面就把此类的文件操作过程一一道来。\n一、打开文件在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：\nvoid open(const char* filename,int mode,int access);\n\n参数：\nfilename：　　要打开的文件名mode：　　　　要打开文件的方式access：　　　打开文件的属性打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：ios::app：　　　以追加的方式打开文件ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性ios::binary：　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文ios::in：　　　 文件以输入方式打开（文件数据输入到内存）ios::out：　　　文件以输出方式打开（内存数据输出到文件）ios::nocreate： 不建立文件，所以文件不存在时打开失败ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败ios::trunc：　　如果文件存在，把文件长度设为0 可以用“或”把以上属性连接起来，如ios::out|ios::binary\n\n打开文件的属性取值是：\n0：普通文件，打开访问\n1：只读文件\n2：隐含文件\n4：系统文件\n可以用“或”或者“+”把以上属性连接起来，如3或1|2就是以只读和隐含属性打开文件。\n例如：以二进制输入方式打开文件c:\\config.sys\nfstream file1; file1.open(“c:\\config.sys”,ios::binary|ios::in,0);\n\n如果open函数只有文件名一个参数，则是以读&#x2F;写普通文件打开，即：\nfile1.open(“c:\\config.sys”);/*等价于*/file1.open(“c:\\config.sys”,ios::in|ios::out,0);\n\n另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：\nfstream file1(“c:\\config.sys”);\n\n特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而ofstream默认以输出方式打开文件。\nifstream file2(“c:\\pdos.def”);//以输入方式打开文件 ofstream file3(“c:\\x.123”);//以输出方式打开文件\n\n所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用ofstream来定义；如果想以输入&#x2F;输出方式来打开，就用fstream来定义。\n二、关闭文件打开的文件使用完成后一定要关闭，fstream提供了成员函数close()来完成此操作，如：file1.close();就把file1相连的文件关闭。\n三、读写文件 读写文件分为文本文件和二进制文件的读取，对于文本文件的读取比较简单，用插入器和析取器就可以了；而对于二进制的读取就要复杂些，下要就详细的介绍这两种方式\n1、文本文件的读写 文本文件的读写很简单：用插入器(&lt;&lt;)向文件输出；用析取器(&gt;&gt;)从文件输入。假设file1是以输入方式打开，file2以输出打开。示例如下：\nfile2&lt;&lt;“I Love You”;//向文件写入字符串&quot;I Love You&quot; int i; file1&gt;&gt;i;//从文件输入一个整数值。\n\n这种方式还有一种简单的格式化能力，比如可以指定输出为16进制等等，具体的格式有以下一些\n操纵符 功能 输入&#x2F;输出 dec 格式化为十进制数值数据 输入和输出 endl 输出一个换行符并刷新此流 输出 ends 输出一个空字符 输出 hex 格式化为十六进制数值数据 输入和输出 oct 格式化为八进制数值数据 输入和输出 setpxecision(int p) 设置浮点数的精度位数 输出\n比如要把123当作十六进制输出：\nfile1&lt;&lt;hex&lt;&lt;123;\n\n要把3.1415926以5位精度输出：\nfile1&lt;&lt;setpxecision(5)&lt;&lt;3.1415926。\n\n2、二进制文件的读写put()put()函数向流写入一个字符，其原型是\nofstream &amp;put(char ch)\n\n使用也比较简单，如\nfile1.put(‘c’);\n\n就是向流写一个字符’c’。\nget()get()函数比较灵活，有3种常用的重载形式：\n一种就是和put()对应的形式：\nifstream &amp;get(char &amp;ch);\n\n功能是从流中读取一个字符，结果保存在引用ch中，如果到文件尾，返回空字符。如\nfile2.get(x);\n\n表示从文件中读取一个字符，并把读取的字符保存在x中。\n另一种重载形式的原型是：\n int get();\n\n这种形式是从流中返回一个字符，如果到达文件尾，返回EOF，如\nx=file2.get();\n\n和上例功能是一样的。\n还有一种形式的原型是：\nifstream &amp;get(char *buf,int num,char delim=&#x27;\\n&#x27;);\n\n这种形式把字符读入由 buf 指向的数组，直到读入了 num 个字符或遇到了由 delim 指定的字符，如果没使用 delim 这个参数，将使用缺省值换行符’\\n’。例如：\nfile2.get(str1,127,‘A’); //从文件中读取字符到字符串str1，当遇到字符’A’或读取了127个字符时终止。\n\n读写数据块要读写二进制数据块，使用成员函数read()和write()成员函数，它们原型如下：\nread(unsigned char *buf,int num); write(const unsigned char*buf,int num);\n\nnum 个字符到 buf 指向的缓存中，如果在还未读入 num 个字符时就到了文件尾，可以用成员函数 int gcount();来取得实际读取的字符数；而``` write() ```从buf 指向的缓存写 num 个字符到文件中，值得注意的是缓存的类型是 ```unsigned char *```，有时可能需要类型转换。例：```C++unsigned char str1[]=“I Love You”;int n[5];ifstream in(“xxx.xxx”); ofstream out(“yyy.yyy”);out.write(str1,strlen(str1));//把字符串str1全部写到yyy.yyy中 in.read((unsigned char*)n,sizeof(n));//从xxx.xxx中读取指定个整数，注意类型转换 in.close();out.close();\n\n四、检测EOF成员函数eof()用来检测是否到达文件尾，如果到达文件尾返回非0值，否则返回0。原型是int eof();\n例：　　\nif(in.eof()) ShowMessage(&quot;已经到达文件尾！&quot;);\n\n五、文件定位和C的文件操作方式不同的是，C++ I&#x2F;O系统管理两个与一个文件相联系的指针。一个是读指针，它说明输入操作在文件中的位置；另一个是写指针，它下次写操作的位置。每次执行输入或输出时，相应的指针自动变化。所以，C++的文件定位分为读位置和写位置的定位，对应的成员函数是seekg()和seekp()。seekg()是设置读位置， seekp是设置写位置。它们最通用的形式如下：\nistream &amp;seekg(streamoff offset,seek_dir origin); ostream &amp;seekp(streamoff offset,seek_dir origin);\n\nstreamoff定义于 iostream.h 中，定义有偏移量 offset 所能取得的最大值，seek_dir 表示移动的基准位置，是一个有以下值的枚举：\nios::beg　　//文件开头ios::cur　　//文件当前位置 ios::end　　//文件结尾\n\n这两个函数一般用于二进制文件，因为文本文件会因为系统对字符的解释而可能与预想的值不同。例：\nfile1.seekg(1234,ios::cur); //把文件的读指针从当前位置向后移1234个字节 file2.seekp(1234,ios::beg); //把文件的写指针从文件开头向后移1234个字节\n\n六.fstream的用法开一个文件fstream f; f.open(“1.txt”, ios::in | ios::binary); if (!f.is_open()) // 检查文件是否成功打开 cout &lt;&lt; “cannot open file.” &lt;&lt; endl; \n\nios::in与ios::bianry均为int型，定义文件打开的方式。ios::in – 打开文件用于读。ios::out – 打开文件用于写，如果文件不存在，则新建一个；存在则清空其内容。ios::binary – 以二进制bit流方式进行读写，默认是ios::text，但最好指定这种读写方式，即使要读写的是文本。因为在ios::text模式下，在写入时’\\ n’字符将转换成两个字符：回车+换行（HEX: 0D 0A) 写入，读入时作逆转换，这容易引起不必要的麻烦。ios::app – 打开文件在文件尾进行写入，即使使用了seekp改变了写入位置，仍将在文件尾写入。ios::ate – 打开文件在文件尾进行写入，但seekp有效。\n读写位置的改变f.seekg(0, ios::beg); &#x2F;&#x2F; 改变读入位置g mean Get f.seekp(0, ios::end); &#x2F;&#x2F; 改变写入位置 p mean Put 第一个参数是偏移量offset(long)，第二个参数是offset相对的位置，三个值： ios::beg – 文件头 ios::end – 文件尾 ios::cur – 当前位置\n文件读写char s[50]; f.read(s, 49); s[50] = ‘\\0’; // 注意要自己加上字符串结束符char *s = “hello”; f.write(s, strlen(s));\n\n七、补充记得读写完成后用f.close()关闭文件。\n例子 下面的程序用于删除带有行号的源程序中的行号。\n#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;//定义要删除的行号格式，下面定义的是型如: #0001 的行号const int LINE_NUM_LENGTH = 5;const char LINE_NUM_START = &#x27;#&#x27;;int main(int argc, char *argv[])&#123;    fstream f;    char *s = NULL;    int n;    for (int i = 1; i &lt; argc; i++)    &#123;        cout &lt;&lt; &quot;Processing file &quot; &lt;&lt; argv[i] &lt;&lt; &quot;......&quot;;        f.open(argv[i], ios::in | ios::binary);        if (!f.is_open())        &#123;            cout &lt;&lt; &quot;CANNOT OPEN&quot;&lt;&lt; endl;            continue;        &#125;        f.seekg(0, ios::end);        n = f.tellg(); // 文件大小        s = new char[n+1];        f.seekg(0, ios::beg);        f.read(s, n);        s[n] = &#x27;\\0&#x27;;        f.close();        // 采用一种简单的判断，遇到LINE_NUM_START后接一个数字，        // 则认为它是一个行号.        for (int j = 0; j &lt; n; j++)        &#123;            if (s[j] == LINE_NUM_START &amp;&amp;            (s[j+1] &gt;= &#x27;0&#x27; &amp;&amp; s[j+1] &lt;= &#x27;9&#x27;))            &#123;                for (int k = j; k &lt; j + LINE_NUM_LENGTH; k++)                    s[k] = &#x27; &#x27;;            &#125;        &#125;        f.open(argv[i], ios::out | ios::binary);        if (!f.is_open())        &#123;            cout &lt;&lt; &quot;CANNOT OPEN&quot; &lt;&lt; endl;            delete[] s;            continue;        &#125;        f.write(s, n);        f.close();        cout &lt;&lt; &quot;OK&quot; &lt;&lt; endl;        delete[] s;    &#125;    return 0;&#125;\n","categories":["编程算法"]},{"title":"今日编程发现--缩进问题","url":"/2021/08/29/cpp-if-else-question-1/","content":"今天偶然看到一段代码是这么写的：\nif(...)    if(...)        ...  else ...\n\n那么问题来了，这么缩进这个else跟的是谁呢？\n其实根据C++原则，else跟的是离他更近的那个if。但是，如果别欣赏这段代码的时候，那可真的难为人家了。\n所以，严格按照语法编代码，保持KISS(Keep it simple,stupid)是最基本的原则。不要写容易混淆的代码。\n"},{"title":"C++ 中string用法详解","url":"/2021/08/01/cpp-string/","content":"本文根据 CC BY-NC-SA 4.0 许可协议参考Nicolai M.Josuttis的文章并进行小部分转载\n\nC++ 语言是个十分优秀的语言，但优秀并不表示完美。还是有许多人不愿意使用C或者C++，为什么？原因众多，其中之一就是C&#x2F;C++的文本处理功能太麻烦，用起来很不方便。\n举例来说，如果文本格式是：用户名 电话号码，文件名name.txt\nTom 23245332 Jenny 22231231 Heny 22183942 Tom 23245332 …\n\n现在我们需要对用户名排序，且只输出不同的姓名。\n那么在shell 编程中，可以这样用：\nawk &#x27;&#123;print $1&#125;&#x27; name.txt | sort | uniq\n\n如果使用C&#x2F;C++ 就麻烦了，他需要做以下工作： 先打开文件，检测文件是否打开，如果失败，则退出。 声明一个足够大得二维字符数组或者一个字符指针数组 读入一行到字符空间 然后分析一行的结构，找到空格，存入字符数组中。 关闭文件 写一个排序函数，或者使用写一个比较函数，使用sort()排序 遍历数组，比较是否有相同的，如果有，则要删除，copy… 输出信息\n你可以用C++或者C语言去实现这个流程。如果一个人的主要工作就是处理这种类似的文本(例如做apache的日志统计和分析),你说他会喜欢C&#x2F;C++么？\n当然，有了STL，这些处理会得到很大的简化。我们可以使用 fstream来代替麻烦的fopen fread fclose, 用vector来代替数组。最重要的是用 string来代替char * 数组，使用sort排序算法来排序，用unique 函数来去重。听起来好像很不错。看看下面代码(例程1）：\n#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;fstream&gt;using namespace std;int main()&#123;    ifstream in(&quot;name.txt&quot;);    string strtmp;    vector&lt;string&gt; vect;    while(getline(in, strtmp, &#x27;\\n&#x27;))    vect.push_back(strtmp.substr(0, strtmp.find(&#x27; &#x27;)));    sort(vect.begin(), vect.end());    vector&lt;string&gt;::iterator it=unique(vect.begin(), vect.end());    copy(vect.begin(), it, ostream_iterator&lt;string&gt;(cout, &quot;\\n&quot;));    return 0;&#125;\n\n也还不错吧，至少会比想象得要简单得多！（代码里面没有对错误进行处理，只是为了说明问题，不要效仿).\n当然，在这个文本格式中，不用vector而使用map会更有扩充性，例如，还可通过人名找电话号码等等，但是使用了map就不那么好用sort了。你可以用map试一试。\n这里string的作用不只是可以存储字符串，还可以提供字符串的比较，查找等。在sort和unique函数中就默认使用了less 和equal_to函数, 上面的一段代码，其实使用了string的以下功能： 存储功能，在getline() 函数中 查找功能，在find() 函数中 子串功能，在substr() 函数中 string operator &lt; , 默认在sort() 函数中调用 string operator &#x3D;&#x3D; , 默认在unique() 函数中调用\n总之，有了string 后，C++的字符文本处理功能总算得到了一定补充，加上配合STL其他容器使用，其在文本处理上的功能已经与perl, shell, php的距离缩小很多了。 因此掌握string 会让你的工作事半功倍。\n1.string使用其实，string并不是一个单独的容器，只是basic_string 模板类的一个typedef 而已，相对应的还有wstring, 你在string 头文件中你会发现下面的代码:\nextern &quot;C++&quot; &#123;typedef basic_string &lt;char&gt; string;typedef basic_string &lt;wchar_t&gt; wstring;&#125; // extern &quot;C++&quot;\n\n由于只是解释string的用法，如果没有特殊的说明，本文并不区分string 和 basic_string的区别。\nstring 其实相当于一个保存字符的序列容器，因此除了有字符串的一些常用操作以外，还有包含了所有的序列容器的操作。字符串的常用操作包括：增加、删除、修改、查找比较、链接、输入、输出等。详细函数列表参看附录。不要害怕这么多函数，其实有许多是序列容器带有的，平时不一定用的上。\n如果你要想了解所有函数的详细用法，你需要查看basic_string，或者下载STL编程手册。这里通过实例介绍一些常用函数。\n1.1 充分使用string 操作符string 重载了许多操作符，包括 +, +&#x3D;, &lt;, &#x3D;, , [], «, »等，正式这些操作符，对字符串操作非常方便。先看看下面这个例子：\n#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123;    string strinfo=&quot;Please input your name:&quot;;    cout &lt;&lt; strinfo ;    cin &gt;&gt; strinfo;    if( strinfo == &quot;winter&quot; )        cout &lt;&lt; &quot;you are winter!&quot;&lt;&lt;endl;    else if( strinfo != &quot;wende&quot; )        cout &lt;&lt; &quot;you are not wende!&quot;&lt;&lt;endl;    else if( strinfo &lt; &quot;winter&quot;)        cout &lt;&lt; &quot;your name should be ahead of winter&quot;&lt;&lt;endl;    else        cout &lt;&lt; &quot;your name should be after of winter&quot;&lt;&lt;endl;    strinfo += &quot; , Welcome to China!&quot;;    cout &lt;&lt; strinfo&lt;&lt;endl;    cout &lt;&lt;&quot;Your name is :&quot;&lt;&lt;endl;    string strtmp = &quot;How are you? &quot; + strinfo;    for(int i = 0 ; i &lt; strtmp.size(); i ++)        cout&lt;&lt;strtmp[i];    return 0;&#125;/*下面是程序的输出Please input your name:Heroyou are not wende!Hero , Welcome to China!How are you? Hero , Welcome to China!*/\n\n有了这些操作符，在STL中仿函数都可以直接使用string作为参数，例如 less, great, equal_to 等，因此在把string作为参数传递的时候，它的使用和int 或者float等已经没有什么区别了。例如，你可以使用：\nmap&lt;string, int&gt; mymap; //以上默认使用了 less&lt;string&gt;\n\n有了 operator + 以后，你可以直接连加，例如：\nstring strinfo=&quot;Winter&quot;;string strlast=&quot;Hello &quot; + strinfo + &quot;!&quot;;string strtest=&quot;Hello &quot; + strinfo + &quot; Welcome&quot; + &quot; to China&quot; + &quot; !&quot;;\n\n看见其中的特点了吗？只要你的等式里面有一个 string 对象，你就可以一直连续”+”，但有一点需要保证的是，在开始的两项中，必须有一项是 string 对象。其原理很简单：\n系统遇到”+“号，发现有一项是string 对象。 系统把另一项转化为一个临时 string 对象。 执行 operator + 操作，返回新的临时string 对象。 如果又发现”+“号，继续第一步操作。\n由于这个等式是由左到右开始检测执行，如果开始两项都是const char，程序自己并没有定义两个const char 的加法，编译的时候肯定就有问题了。\n有了操作符以后，assign(), append(), compare(), at()等函数，除非有一些特殊的需求时，一般是用不上。当然at()函数还有一个功能，那就是检查下标是否合法，如果是使用：\nstring str=&quot;winter&quot;;//下面一行有可能会引起程序中断错误str[100]=&#x27;!&#x27;;//下面会抛出异常:throws: out_of_rangecout&lt;&lt;str.at(100)&lt;&lt;endl;\n\n了解了吗？如果你希望效率高，还是使用[]来访问，如果你希望稳定性好，最好使用at()来访问。\n1.2 眼花缭乱的string find 函数由于查找是使用最为频繁的功能之一，string 提供了非常丰富的查找函数。其列表如下： 函数名 描述 find 查找 rfind 反向查找 find_first_of 查找包含子串中的任何字符，返回第一个位置 find_first_not_of 查找不包含子串中的任何字符，返回第一个位置 find_last_of 查找包含子串中的任何字符，返回最后一个位置 find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置以上函数都是被重载了4次，以下是以find_first_of 函数为例说明他们的参数，其他函数和其参数一样，也就是说总共有24个函数 ：\nsize_type find_first_of(const basic_string&amp; s, size_type pos = 0)size_type find_first_of(const charT* s, size_type pos, size_type n)size_type find_first_of(const charT* s, size_type pos = 0)size_type find_first_of(charT c, size_type pos = 0)\n\n所有的查找函数都返回一个size_type类型，这个返回值一般都是所找到字符串的位置，如果没有找到，则返回string::npos。有一点需要特别注意，所有和string::npos的比较一定要用string::size_type来使用，不要直接使用int 或者unsigned int等类型。其实string::npos表示的是-1, 看看头文件：\ntemplate &lt;class _CharT, class _Traits, class _Alloc&gt;const basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_typebasic_string&lt;_CharT,_Traits,_Alloc&gt;::npos= basic_string&lt;_CharT,_Traits,_Alloc&gt;::size_type) -1;\n\nfind 和 rfind 都还比较容易理解，一个是正向匹配，一个是逆向匹配，后面的参数pos都是用来指定起始查找位置。对于find_first_of 和find_last_of 就不是那么好理解。\nfind_first_of 是给定一个要查找的字符集，找到这个字符集中任何一个字符所在字符串中第一个位置。或许看一个例子更容易明白。\n有这样一个需求：过滤一行开头和结尾的所有非英文字符。看看用string 如何实现：\n#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123;    string strinfo=&quot; //*---Hello Word!......------&quot;;    string strset=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;    int first = strinfo.find_first_of(strset);     if(first == string::npos)     &#123;      cout&lt;&lt;&quot;not find any characters&quot;&lt;&lt;endl;      return -1;     &#125;     int last = strinfo.find_last_of(strset);     if(last == string::npos)     &#123;      cout&lt;&lt;&quot;not find any characters&quot;&lt;&lt;endl;      return -1;    &#125;     cout &lt;&lt; strinfo.substr(first, last - first + 1)&lt;&lt;endl;     return 0;&#125;\n\n这里把所有的英文字母大小写作为了需要查找的字符集，先查找第一个英文字母的位置，然后查找最后一个英文字母的位置，然后用substr 来的到中间的一部分，用于输出结果。下面就是其结果：Hello Word前面的符号和后面的符号都没有了。像这种用法可以用来查找分隔符，从而把一个连续的字符串分割成为几部分，达到 shell 命令中的 awk 的用法。特别是当分隔符有多个的时候，可以一次指定。例如有这样的需求：\n张三|3456123, 湖南李四,4564234| 湖北王小二, 4433253|北京...\n\n我们需要以 “|” “,“为分隔符，同时又要过滤空格，把每行分成相应的字段。\n1.3 string insert, replace, erase\n了解了string 的操作符，查找函数和substr，其实就已经了解了string的80%的操作了。insert函数, replace函数和erase函数在使用起来相对简单。下面以一个例子来说明其应用。 string只是提供了按照位置和区间的replace函数，而不能用一个string字串来替换指定string中的另一个字串。这里写一个函数来实现这个功能：\nvoid string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)&#123;     string::size_type pos=0;    string::size_type srclen=strsrc.size();    string::size_type dstlen=strdst.size();    while( (pos=strBig.find(strsrc, pos)) != string::npos)     &#123;      strBig.replace(pos, srclen, strdst);      pos += dstlen;     &#125;&#125;\n\n看看如何调用：\n#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main()&#123;     string strinfo=&quot;This is Winter, Winter is a programmer. Do you know Winter?&quot;;    cout&lt;&lt;&quot;Orign string is :\\n&quot;&lt;&lt;strinfo&lt;&lt;endl;    string_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;);     cout&lt;&lt;&quot;After replace Winter with wende, the string is :\\n&quot;&lt;&lt;strinfo&lt;&lt;endl;     return 0;&#125;\n\n其输出结果：\nOrign string is :This is Winter, Winter is a programmer. Do you know Winter?After replace Winter with wende, the string is :This is wende, wende is a programmer. Do you know wende?\n\n如果不用replace函数，则可以使用erase和insert来替换，也能实现string_replace函数的功能：\nvoid string_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)&#123;     string::size_type pos=0;     string::size_type srclen=strsrc.size();    string::size_type dstlen=strdst.size();     while( (pos=strBig.find(strsrc, pos)) != string::npos)    &#123;     strBig.erase(pos, srclen);     strBig.insert(pos, strdst);     pos += dstlen;    &#125;&#125;\n\n当然，这种方法没有使用replace来得直接.\n2 string 和C-style字符串现在看了这么多例子，发现const char* 可以和string 直接转换，例如我们在上面的例子中，使用\nstring_replace(strinfo, &quot;Winter&quot;, &quot;wende&quot;);来代用void\nstring_replace(string &amp; strBig, const string &amp; strsrc, const string &amp;strdst)在C语言中只有char* 和 const char*，为了使用起来方便，string提供了三个函数满足其要求：\nconst charTc_str() constconst charT data() constsize_type copy(charT* buf, size_type n, size_type pos &#x3D; 0) const其中： c_str 直接返回一个以\\0结尾的字符串。 data 直接以数组方式返回string的内容，其大小为size()的返回值，结尾并没有\\0字符。 copy 把string的内容拷贝到buf空间中。 你或许会问，c_str()的功能包含data()，那还需要data()函数干什么？看看源码：\nconst charT* c_str() const&#123;     if (length () == 0)         return &quot;&quot;;    terminate ();     return data ();&#125;\n\n原来c_str()的流程是：先调用terminate()，然后在返回data()。因此如果你对效率要求比较高，而且你的处理又不一定需要以\\0的方式结束，你最好选择data()。但是对于一般的C函数中，需要以const char*为输入参数，你就要使用c_str()函数。\n对于c_str() data()函数，返回的数组都是由string本身拥有，千万不可修改其内容。其原因是许多string实现的时候采用了引用机制，也就是说，有可能几个string使用同一个字符存储空间。而且你不能使用sizeof(string)来查看其大小。详细的解释和实现查看Effective STL的条款15：小心string实现的多样性。\n另外在你的程序中，只在需要时才使用c_str()或者data()得到字符串，每调用一次，下次再使用就会失效，如：\nstring strinfo(&quot;this is Winter&quot;);...//最好的方式是:foo(strinfo.c_str());//也可以这么用:const char* pstr=strinfo.c_str();foo(pstr);//不要再使用了pstr了, 下面的操作已经使pstr无效了。strinfo += &quot; Hello!&quot;;foo(pstr);//错误！\n\n会遇到什么错误？当你幸运的时候pstr可能只是指向&quot;this is Winter Hello!“的字符串，如果不幸运，就会导致程序出现其他问题，总会有一些不可遇见的错误。总之不会是你预期的那个结果。\n3 string 和 Charactor Traits 了解了string的用法，该详细看看string的真相了前面提到string 只是basic_string的一个typedef。看看basic_string 的参数：\ntemplate &lt;class charT, class traits = char_traits&lt;charT&gt;,class Allocator = allocator&lt;charT&gt; &gt;class basic_string&#123;//...&#125;char_traits不仅是在basic_string 中有用，在basic_istream 和 basic_ostream中也需要用到。 就像Steve Donovan在过度使用C++模板中提到的，这些确实有些过头了，要不是系统自己定义了相关的一些属性，而且用了个typedef，否则还真不知道如何使用。但复杂总有复杂道理。有了char_traits，你可以定义自己的字符串类型。当然，有了char_traits &lt; char &gt; 和char_traits &lt; wchar_t &gt; 你的需求使用已经足够了，为了更好的理解string ，咱们来看看char_traits都有哪些要求。如果你希望使用你自己定义的字符，你必须定义包含下列成员的结构： 表达式 描述```C++char_type 字符类型int_type int 类型pos_type 位置类型off_type 表示位置之间距离的类型state_type 表示状态的类型assign(c1,c2) 把字符c2赋值给c1eq(c1,c2) 判断c1,c2 是否相等lt(c1,c2) 判断c1是否小于c2length(str) 判断str的长度compare(s1,s2,n) 比较s1和s2的前n个字符copy(s1,s2, n) 把s2的前n个字符拷贝到s1中move(s1,s2, n) 把s2中的前n个字符移动到s1中assign(s,n,c) 把s中的前n个字符赋值为cfind(s,n,c) 在s的前n个字符内查找ceof() 返回end-of-fileto_int_type(c) 将c转换成int_typeto_char_type(i) 将i转换成char_typenot_eof(i) 判断i是否为EOFeq_int_type(i1,i2) 判断i1和i2是否相等\n\n想看看实际的例子，你可以看看sgi STL的char_traits结构源码.\n现在默认的string版本中，并不支持忽略大小写的比较函数和查找函数，如果你想练练手，你可以试试改写一个char_traits , 然后生成一个case_string类, 也可以在string 上做继承，然后派生一个新的类，例如：ext_string，提供一些常用的功能，例如：\n定义分隔符。给定分隔符，把string分为几个字段。 提供替换功能。例如，用winter, 替换字符串中的wende 大小写处理。例如，忽略大小写比较，转换等 整形转换。例如把”123”字符串转换为123数字。 这些都是常用的功能，如果你有兴趣可以试试。其实有人已经实现了，看看Extended STL string。如果你想偷懒，下载一个头文件就可以用，有了它确实方便了很多。要是有人能提供一个支持正则表达式的string，我会非常乐意用。\n4.string 建议使用string 的方便性就不用再说了，这里要重点强调的是string的安全性。 string并不是万能的，如果你在一个大工程中需要频繁处理字符串，而且有可能是多线程，那么你一定要慎重(当然，在多线程下你使用任何STL容器都要慎重)。 string的实现和效率并不一定是你想象的那样，如果你对大量的字符串操作，而且特别关心其效率，那么你有两个选择，首先，你可以看看你使用的STL版本中string实现的源码；另一选择是你自己写一个只提供你需要的功能的类。 string的c_str()函数是用来得到C语言风格的字符串，其返回的指针不能修改其空间。而且在下一次使用时重新调用获得新的指针。 string的data()函数返回的字符串指针不会以’\\0’结束，千万不可忽视。 尽量去使用操作符，这样可以让程序更加易懂\n5 小结 难怪有人说：string 使用方便功能强，我们一直用它！\n6 附录string 函数列表 函数名 描述begin 得到指向字符串开头的Iteratorend 得到指向字符串结尾的Iteratorrbegin 得到指向反向字符串开头的Iteratorrend 得到指向反向字符串结尾的Iteratorsize 得到字符串的大小length 和size函数功能相同max_size 字符串可能的最大大小capacity 在不重新分配内存的情况下，字符串可能的大小empty 判断是否为空operator[] 取第几个元素，相当于数组c_str 取得C风格的const char* 字符串data 取得字符串内容地址operator= 赋值操作符reserve 预留空间swap 交换函数insert 插入字符append 追加字符push_back 追加字符operator+= += 操作符erase 删除字符串clear 清空字符容器中所有内容resize 重新分配空间assign 和赋值操作符一样replace 替代copy 字符串到空间find 查找rfind 反向查找find_first_of 查找包含子串中的任何字符，返回第一个位置find_first_not_of 查找不包含子串中的任何字符，返回第一个位置find_last_of 查找包含子串中的任何字符，返回最后一个位置find_last_not_of 查找不包含子串中的任何字符，返回最后一个位置substr 得到字串compare 比较字符串operator+ 字符串链接operator== 判断是否相等operator!= 判断是否不等于operator&lt; 判断是否小于operator&gt;&gt; 从输入流中读入字符串operator&lt;&lt; 字符串写入输出流getline 从输入流中读入一行 \n\n之所以抛弃char*的字符串而选用C++标准程序库中的string类，是因为他和前者比较起来，不必担心内存是否足够、字符串长度等等，而且作为一个类出现，他集成的操作函数足以完成我们大多数情况下(甚至是100%)的需要。我们可以用 &#x3D; 进行赋值操作，&#x3D;&#x3D; 进行比较，+ 做串联（是不是很简单?）。我们尽可以把它看成是C++的基本数据类型。 好了，进入正题……… 首先，为了在我们的程序中使用string类型，我们必须包含头文件&lt;cstring&gt;。\n1．声明一个C++字符串声明一个字符串变量很简单：string Str;这样我们就声明了一个字符串变量，但既然是一个类，就有构造函数和析构函数。上面的声明没有传入参数，所以就直接使用了string的默认的构造函数，这个函数所作的就是把Str初始化为一个空字符串。String类的构造函数和析构函数如下：\na)    string s;  //生成一个空字符串sb)    string s(str) //拷贝构造函数 生成str的复制品c)    string s(str,stridx) //将字符串str内“始于位置stridx”的部分当作字符串的初值d)    string s(str,stridx,strlen) //将字符串str内“始于stridx且长度顶多strlen”的部分作为字符串的初值e)    string s(cstr) //将C字符串作为s的初值f)    string s(chars,chars_len) //将C字符串前chars_len个字符作为字符串s的初值。g)    string s(num,c) //生成一个字符串，包含num个c字符h)    string s(beg,end) //以区间beg;end(不包含end)内的字符作为字符串s的初值i)    s.~string() //销毁所有字符，释放内存\n\n都很简单，我就不解释了。\n2．字符串操作函数这里是C++字符串的重点，我先把各种操作函数罗列出来，不喜欢把所有函数都看完的人可以在这里找自己喜欢的函数，再到后面看他的详细解释。\na) =,assign()   //赋以新值b) swap()   //交换两个字符串的内容c) +=,append(),push_back() //在尾部添加字符d) insert() //插入字符e) erase() //删除字符f) clear() //删除全部字符g) replace() //替换字符h) + //串联字符串i) ==,!=,&lt;,&lt;=,&gt;,&gt;=,compare()  //比较字符串j) size(),length()  //返回字符数量k) max_size() //返回字符的可能最大个数l) empty()  //判断字符串是否为空m) capacity() //返回重新分配之前的字符容量n) reserve() //保留一定量内存以容纳一定数量的字符o) [ ], at() //存取单一字符p) &gt;&gt;,getline() //从stream读取某值q) &lt;&lt;  //将谋值写入streamr) copy() //将某值赋值为一个C_strings) c_str() //将内容以C_string返回t) data() //将内容以字符数组形式返回u) substr() //返回某个子字符串v)查找函数w)begin() end() //提供类似STL的迭代器支持x) rbegin() rend() //逆向迭代器y) get_allocator() //返回配置器\n\n2．1 C++字符串和C字符串的转换C++提供的由C++字符串得到对应的C_string的方法是使用data()、c_str()和copy()，其中，data()以字符数组的形式返回字符串内容，但并不添加’\\0’。c_str()返回一个以‘\\0’结尾的字符数组，而copy()则把字符串的内容复制或写入既有的c_string 或字符数组内。C++字符串并不以’\\0’结尾。我的建议是在程序中能使用C++字符串就使用，除非万不得已不选用c_string。由于只是简单介绍，详细介绍掠过，谁想进一步了解使用中的注意事项可以给我留言(到我的收件箱)。我详细解释。\n2．2 大小和容量函数 一个C++字符串存在三种大小：a)现有的字符数，函数是size()和length()，他们等效。Empty()用来检查字符串是否为空。 b)max_size() 这个大小是指当前C++字符串最多能包含的字符数，很可能和机器本身的限制或者字符串所在位置连续内存的大小有关系。我们一般情况下不用关心他，应该大小足够我们用的。但是不够用的话，会抛出length_error异常c)capacity()重新分配内存之前 string所能包含的最大字符数。这里另一个需要指出的是reserve()函数，这个函数为string重新分配内存。重新分配的大小由其参数决定，默认参数为0，这时候会对string进行非强制性缩减。\n还有必要再重复一下C++字符串和C字符串转换的问题，许多人会遇到这样的问题，自己做的程序要调用别人的函数、类什么的（比如数据库连接函数 Connect(char*,char*)），但别人的函数参数用的是char形式的，而我们知道，c_str()、data()返回的字符数组由该字符串拥有，所以是一种const char,要想作为上面提及的函数的参数，还必须拷贝到一个char*,而我们的原则是能不使用C字符串就不使用。那么，这时候我们的处理方式是：如果此函数对参数(也就是char*)的内容不修改的话，我们可以这样Connect((char*)UserID.c_str(), (char*)PassWD.c_str()),但是这时候是存在危险的，因为这样转换后的字符串其实是可以修改的（有兴趣地可以自己试一试），所以我强调除非函数调用的时候不对参数进行修改，否则必须拷贝到一个char上去。当然，更稳妥的办法是无论什么情况都拷贝到一个char上去。同时我们也祈祷现在仍然使用C字符串进行编程的高手们（说他们是高手一点儿也不为过，也许在我们还穿开裆裤的时候他们就开始编程了，哈哈…）写的函数都比较规范，那样我们就不必进行强制转换了。\n2．3元素存取 我们可以使用下标操作符[] 和函数at()对元素包含的字符进行访问。但是应该注意的是操作符[]并不检查索引是否有效（有效索引 0~str.length()），如果索引失效，会引起未定义的行为。而at()会检查，如果使用at()的时候索引无效，会抛出 out_of_range异常。 有一个例外不得不说，const string a;的操作符[]对索引值是a.length()仍然有效，其返回值是’\\0’。其他的各种情况，a.length()索引都是无效的。举例如下：\nconst string Cstr(“const string”);string Str(“string”);Str[3];    //okStr.at(3);  //okStr[100]; //未定义的行为Str.at(100);  //throw out_of_rangeStr[Str.length()]  //未定义行为Cstr[Cstr.length()] //返回 ‘\\0’Str.at(Str.length());//throw out_of_rangeCstr.at(Cstr.length()) ////throw out_of_range\n\n我不赞成类似于下面的引用或指针赋值： char&amp; r=s[2]; char* p= &amp;s[3];\n因为一旦发生重新分配，r,p立即失效。避免的方法就是不使用。\n2．4比较函数 C++字符串支持常见的比较操作符（&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;,&#x3D;&#x3D;,!&#x3D;），甚至支持string与C-string的比较(如 str&lt;”hello”)。在使用&gt;,&gt;&#x3D;,&lt;,&lt;&#x3D;这些操作符的时候是根据“当前字符特性”将字符按字典顺序进行逐一得比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小。同时，string(“aaaa”) &lt;string(aaaaa)。 另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。他返回一个整数来表示比较结果，返回值意义如下：0-相等 〉0-大于 &lt;0-小于。举例如下：\nstring s(“abcd”);s.compare(“abcd”); //返回0s.compare(“dcba”); //返回一个小于0的值s.compare(“ab”); //返回大于0的值s.compare(s); //相等s.compare(0,2,s,2,2); //用”ab”和”cd”进行比较 小于零s.compare(1,2,”bcx”,2); //用”bc”和”bc”比较。\n\n怎么样？功能够全的吧！什么？还不能满足你的胃口？好吧，那等着，后面有更个性化的比较算法。先给个提示，使用的是STL的比较算法。什么？对STL一窍不通？你重修吧！\n2．5 更改内容 这在字符串的操作中占了很大一部分。 首先讲赋值，第一个赋值方法当然是使用操作符&#x3D;，新值可以是string(如：s&#x3D;ns) 、c_string(如：s&#x3D;”gaint”)甚至单一字符（如：s&#x3D;’j’）。还可以使用成员函数assign()，这个成员函数可以使你更灵活的对字符串赋值。还是举例说明吧：\ns.assign(str); //直接s.assign(str,1,3);//如果str是”iamangel” 就是把”ama”赋给字符串s.assign(str,2,string::npos);//把字符串str从索引值2开始到结尾赋给ss.assign(“gaint”); //不说s.assign(“nico”,5);//把’n’ ‘I’ ‘c’ ‘o’ ‘\\0’赋给字符串s.assign(5,’x’);//把五个x赋给字符串\n\n把字符串清空的方法有三个：s&#x3D;””;s.clear();s.erase();(我越来越觉得举例比说话让别人容易懂！)。 string提供了很多函数用于插入（insert）、删除（erase）、替换（replace）、增加字符。 先说增加字符（这里说的增加是在尾巴上），函数有 +&#x3D;、append()、push_back()。举例如下：\ns+=str;//加个字符串s+=”my name is jiayp”;//加个C字符串s+=’a’;//加个字符s.append(str);s.append(str,1,3);//不解释了 同前面的函数参数assign的解释s.append(str,2,string::npos)//不解释了s.append(“my name is jiayp”);s.append(“nico”,5);s.append(5,’x’);s.push_back(‘a’);//这个函数只能增加单个字符 对STL熟悉的理解起来很简单\n\n也许你需要在string中间的某个位置插入字符串，这时候你可以用insert()函数，这个函数需要你指定一个安插位置的索引，被插入的字符串将放在这个索引的后面。\ns.insert(0,”my name”);s.insert(1,str);\n\n这种形式的insert()函数不支持传入单个字符，这时的单个字符必须写成字符串形式(让人恶心)。既然你觉得恶心，那就不得不继续读下面一段话：为了插入单个字符，insert()函数提供了两个对插入单个字符操作的重载函数：insert(size_type index,size_type num,chart c)和insert(iterator pos,size_type num,chart c)。其中size_type是无符号整数，iterator是char*,所以，你这么调用insert函数是不行的：insert(0,1,’j’);这时候第一个参数将转换成哪一个呢？所以你必须这么写：insert((string::size_type)0,1,’j’)！第二种形式指出了使用迭代器安插字符的形式，在后面会提及。顺便提一下，string有很多操作是使用STL的迭代器的，他也尽量做得和STL靠近。 删除函数erase()的形式也有好几种（真烦！），替换函数replace()也有好几个。举例吧：\nstring s=”il8n”;s.replace(1,2,”nternationalizatio”);//从索引1开始的2个替换成后面的C_strings.erase(13);//从索引13开始往后全删除s.erase(7,5);//从索引7开始往后删5个\n\n2．6提取子串和字符串连接\n题取子串的函数是：substr(),形式如下：\ns.substr();//返回s的全部内容s.substr(11);//从索引11往后的子串s.substr(5,6);//从索引5开始6个字符\n\n把两个字符串结合起来的函数是+。（谁不明白请致电120）\n2．7输入输出操作 1．» 从输入流读取一个string。 2．« 把一个string写入输出流。 另一个函数就是getline(),他从输入流读取一行内容，直到遇到分行符或到了文件尾。\n2．8搜索与查找 查找函数很多，功能也很强大，包括了：\nfind()rfind()find_first_of()find_last_of()find_first_not_of()find_last_not_of()\n\n这些函数返回符合搜索条件的字符区间内的第一个字符的索引，没找到目标就返回npos。所有的函数的参数说明如下： 第一个参数是被搜寻的对象。第二个参数（可有可无）指出string内的搜寻起点索引，第三个参数（可有可无）指出搜寻的字符个数。比较简单，不多说 不理解的可以向我提出，我再仔细的解答。当然，更加强大的STL搜寻在后面会有提及。 最后再说说npos的含义，string::npos的类型是string::size_type,所以，一旦需要把一个索引与npos相比，这个索引值必须是string::size)type类型的，更多的情况下，我们可以直接把函数和npos进行比较（如：if(s.find(“jia”)&#x3D;&#x3D;string::npos)）。\n","categories":["编程算法"]},{"title":"洛谷P5380鸭旗解法","url":"/2021/10/05/cppluogu-p5380/","content":"第一步 初始化就按上图的格式进行初始化棋盘，注意棋盘的方向与数组下标，代码如下：\nvoid begining()&#123;\t\t//Blue\t//underline character\tmapp[1][1][0]=5,mapp[1][2][0]=4,mapp[1][3][0]=3,mapp[1][4][0]=2,mapp[1][5][0]=1;\tmapp[1][6][0]=2,mapp[1][7][0]=3,mapp[1][8][0]=4,mapp[1][9][0]=5;\t//duck\tmapp[3][1][0]=6,mapp[3][9][0]=6;\t//soldier\tmapp[4][1][0]=7,mapp[4][3][0]=7,mapp[4][5][0]=7,mapp[4][7][0]=7,mapp[4][9][0]=7;\t\t//Red\t//underline character\tmapp[10][1][1]=5,mapp[10][2][1]=4,mapp[10][3][1]=3,mapp[10][4][1]=2,mapp[10][5][1]=1;\tmapp[10][6][1]=2,mapp[10][7][1]=3,mapp[10][8][1]=4,mapp[10][9][1]=5;\t//duck\tmapp[8][1][1]=6,mapp[8][9][1]=6;\t//soldier\tmapp[7][1][1]=7,mapp[7][3][1]=7,mapp[7][5][1]=7,mapp[7][7][1]=7;mapp[7][9][1]=7;\t&#125;\n\n这里我调换了红蓝双方的顺序，所以就不用翻转棋盘。\n第二步 基础操作函数：①attack 移动&#x2F;攻击因为移动也是一种特殊的攻击，所以也可以把移动归入攻击一栏,通过from，to参数，考虑攻击前后的敌我关系，具体代码如下：\nvoid attack(int x1,int y1,int x2,int y2,int from,int to)&#123;\t\tmapp[x2][y2][from]=mapp[x1][y1][from];\t\tmapp[x1][y1][from]=0;\t\tif(to!=-1)mapp[x2][y2][to]=0;&#125;\n\n②getgroup 分组对于一个坐标的棋子，我们肯定要知道它属于哪一方，自然要写一个函数来获取分组。\nint getgroup(int x,int y)&#123;\tif(mapp[x][y][0])return 0;\telse if(mapp[x][y][1])return 1;\telse return -1;&#125;\n\n③getcaptain 获取主帅位置这一函数将在最后判断将军时用到。比较好理解。\nNode getcaptain(int gr)&#123;\tNode t;\tfor(int i=1;i&lt;=10;i++)&#123;\t\tfor(int j=1;j&lt;=9;j++)&#123;\t\t\tif(mapp[i][j][gr]==1)&#123;\t\t\t\tt.x=i,t.y=j;\t\t\t\treturn t;\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n第三步 判断每个棋子移动的合法性这是整道题的重中之重，这里将一一讲解：\n①captain 将的移动这是最为简单的移动之一，只要求移动前后的坐标差即可。\nbool captain(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint tx=abs(x1-x2),ty=abs(y1-y2);\tif(tx==1&amp;&amp;ty==0)return true;\telse if(tx==0&amp;&amp;ty==1)return true;\telse return false;&#125;\n\n②guard 士的移动这个移动与将差不多，同样求坐标差\nbool guard(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint tx=abs(x1-x2),ty=abs(y1-y2);\tif(tx==1&amp;&amp;ty==1)\treturn true;\telse return false;&#125;\n\n③elephant 象的移动这个移动就有点复杂，注意要判断是否移动受阻，可以单独开一个数组判断障碍，这个思路就有点像大家初学BFS的时候模拟移动。\nbool elephant(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint aimx[4]=&#123;-2,-2,2,2&#125;,aimy[4]=&#123;-2,2,-2,2&#125;;\tint stx[4]=&#123;-1,-1,1,1,&#125;,sty[4]=&#123;-1,1,-1,1&#125;;\tfor(int i=0;i&lt;4;i++)&#123;\t\tint tx=x1+aimx[i],ty=y1+aimy[i];\t\tif(tx==x2&amp;&amp;ty==y2)&#123;\t\t\tint ttx=x1+stx[i],tty=y1+sty[i];\t\t\tif(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;\n\n④horse 马的移动与象差不多，只要注意马的移动的x,y轴要一一对应，而障碍位置就是马的上下左右4个点。\nbool horse(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint aimx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,aimy[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;;\tint stx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,sty[8]=&#123;0,0,1,1,0,0,-1,-1&#125;;\tfor(int i=0;i&lt;8;i++)&#123;\t\tint tx=x1+aimx[i],ty=y1+aimy[i];\t\tif(tx==x2&amp;&amp;ty==y2)&#123;\t\t\tint ttx=x1+stx[i],tty=y1+sty[i];\t\t\tif(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;\n\n⑤car 车的移动车的移动相对简单，只要一重循环模拟即可。注意一点：要先判断两点时候同行或者同列，否则模拟是无意义的。\nbool car(int x1,int y1,int x2,int y2,int from,int to)&#123;\tif(x1!=x2&amp;&amp;y1!=y2)return false;\tif(x1==x2)&#123;\t\tfor(int i=min(y1,y2)+1;i&lt;=max(y1,y2)-1;i++)&#123;\t\t\tif(mapp[x1][i][0]||mapp[x1][i][1])\t\t\t\treturn false;\t\t&#125;\t&#125;\tif(y1==y2)&#123;\t\tfor(int i=min(x1,x2)+1;i&lt;=max(x1,x2)-1;i++)&#123;\t\t\tif(mapp[i][y1][0]||mapp[i][y1][1])&#123;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t&#125;\treturn true;&#125;\n\n⑥duck 鸭的移动鸭这个棋子是所有棋子中最难模拟的，但仔细分析，可以发现，鸭的障碍就是马对应方向的障碍与立足点，所以开2个数组去判断鸭的两层障碍即可。\nbool duck(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint aimx[8]=&#123;-3,-3,-2,2,3,3,2,-2&#125;,aimy[8]=&#123;-2,2,3,3,2,-2,-3,-3&#125;;\tint stx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,sty[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;;\tint subx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,suby[8]=&#123;0,0,1,1,0,0,-1,-1&#125;;\tfor(int i=0;i&lt;8;i++)&#123;\t\tint tx=x1+aimx[i],ty=y1+aimy[i];\t\tif(tx==x2&amp;&amp;ty==y2)&#123;\t\t\tint ttx=x1+stx[i],tty=y1+sty[i];\t\t\tint tttx=x1+subx[i],ttty=y1+suby[i];\t\t\tif(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0&amp;&amp;mapp[tttx][ttty][0]==0&amp;&amp;mapp[tttx][ttty][1]==0)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;\n\n⑦soldier 兵的移动仔细观察，不难发现，兵的移动就是将的移动加上士的移动。所以直接调用上面的函数即可。\nbool soldier(int x1,int y1,int x2,int y2,int from,int to)&#123;\tif(captain(x1,y1,x2,y2,from,to))return true;\tif(guard(x1,y1,x2,y2,from,to))return true;\treturn false;&#125;\n\n第三步 移动操作有了之前的几个函数做铺垫，这个操作就好写很多，先判断是否符合题目中要求，比如同方，起始点无己方棋子等等，然后一一判断是哪种棋子，调用对应的函数即可。如果合法，那么就移动&#x2F;对敌方棋子攻击，调用attack函数，否则输出无解，注意一点，在移动棋子前要先输出前两个信息，即移动的棋子和被攻击的棋子，因为在移动后信息会被改变。 最后输出后两个信息，在下文会讲到。\nvoid move(int x1,int y1,int x2,int y2,int from,int to)&#123;\t//nowgame();\t\tif(from!=roun)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t//check the size\tif(x1&lt;1||x2&lt;1||x1&gt;10||x2&gt;10||y1&lt;1||y2&lt;1||y1&gt;9||y2&gt;9)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//check the gruops\tif(from==to)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//check the from\tif(from==-1)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//check if the game is over\tif(flg==1)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//captain\tif(mapp[x1][y1][from]==1)&#123;\t\tif(captain(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t//guard\tif(mapp[x1][y1][from]==2)&#123;\t\tif(guard(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t\t\t//elephant\tif(mapp[x1][y1][from]==3)&#123;\t\tif(elephant(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t\t\t//horse\tif(mapp[x1][y1][from]==4)&#123;\t\tif(horse(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t//car\tif(mapp[x1][y1][from]==5)&#123;\t\tif(car(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t//duck\t\t\tif(mapp[x1][y1][from]==6)&#123;\t\tif(duck(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t\t\t//soldier\tif(mapp[x1][y1][from]==7)&#123;\t\t\tif(soldier(x1,y1,x2,y2,from,to))&#123; \t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t&#125;\n\n第四步 判断将军将军这个问题看似很难解决，其实换一种思路即可，假设每个敌方棋子都可以将军，然后调用之前的函数，判断假设是否成立，如果成立，说明存在将军，否则则不存在将军。\n这样一来，代码就非常好写了：遍历每个点，对于有敌方棋子的点，就做出假设，然后判断假设。并且这里要用到之前的getcaptain函数来获取两方将的位置。\n代码如下：\nbool cankill()&#123;\tNode blue,red;\tblue=getcaptain(0),red=getcaptain(1);\tfor(int i=1;i&lt;=10;i++)&#123;\t\tfor(int j=1;j&lt;=9;j++)&#123;\t\t\tif(mapp[i][j][0])&#123;\t\t\t\tif(mapp[i][j][0]==1)\t\t\t\t\tif(captain(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==2)\t\t\t\t\tif(guard(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==3)\t\t\t\t\tif(elephant(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==4)\t\t\t\t\tif(horse(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==5)\t\t\t\t\tif(car(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==6)\t\t\t\t\tif(duck(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==7)\t\t\t\t\tif(soldier(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t&#125;\t\t\tif(mapp[i][j][1])&#123;\t\t\t\tif(mapp[i][j][1]==1)\t\t\t\t\tif(captain(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==2)\t\t\t\t\tif(guard(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==3)\t\t\t\t\tif(elephant(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==4)\t\t\t\t\tif(horse(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==5)\t\t\t\t\tif(car(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==6)\t\t\t\t\tif(duck(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==7)\t\t\t\t\tif(soldier(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;\n\n第五步 判断游戏是否结束这个问题非常好解决，跑一遍二重循环，统计将的个数，如果小于2，游戏一定结束，注意游戏结束后要设置一个flg，使对接下来命令的处理都是无解。\n代码如下：\nbool isend()&#123;\t\tint t=0;\tfor(int k=0;k&lt;=1;k++)&#123;\t\tfor(int i=1;i&lt;=10;i++)&#123;\t\t\tfor(int j=1;j&lt;=9;j++)&#123;\t\t\t\tif(mapp[i][j][k]==1)t++;\t\t\t&#125;\t\t&#125;\t&#125;\tif(t&lt;2)&#123;\t\tflg=1;\t\treturn true;\t\t&#125;\telse return false;\t&#125;\n\n第六步 输出因为在move函数中已经将前两个信息输出，所以这里只要输出后两个信息即可，直接调用上面的函数，同时在输出的时候更新当前应当走棋的阵营。 对于不合法的调用，输出无解即可。\n代码如下：\nvoid print(int M_C,int M_G,int K_C,int K_G,int canmove)&#123;\t//canmove?\tif(canmove==1)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\troun=1-roun;\t\t//End?\tif(isend())&#123;\t\tcout&lt;&lt;&quot;no;yes&quot;&lt;&lt;endl;\t\t&#125;\telse \t&#123;\t\tif(cankill())cout&lt;&lt;&quot;yes;&quot;;\t\telse cout&lt;&lt;&quot;no;&quot;;\t\tcout&lt;&lt;&quot;no&quot;&lt;&lt;endl;\t&#125;&#125;\n\nTip：主程序中对于每条指令，调用move函数即可。\n完整代码献上完整代码，10K,396行:\n#include&lt;bits/stdc++.h&gt;using namespace std;//begining wordsint Q;struct Node&#123;\tint x,y;&#125;;int mapp[20][20][2];string name[10]=&#123;&quot;&quot;,&quot;captain&quot;,&quot;guard&quot;,&quot;elephant&quot;,&quot;horse&quot;,&quot;car&quot;,&quot;duck&quot;,&quot;soldier&quot;&#125;;string group[3]=&#123;&quot;red&quot;,&quot;blue&quot;&#125;;bool flg=0;bool roun=0;void begining()&#123;\t\t//Blue\t//underline character\tmapp[1][1][0]=5,mapp[1][2][0]=4,mapp[1][3][0]=3,mapp[1][4][0]=2,mapp[1][5][0]=1;\tmapp[1][6][0]=2,mapp[1][7][0]=3,mapp[1][8][0]=4,mapp[1][9][0]=5;\t//duck\tmapp[3][1][0]=6,mapp[3][9][0]=6;\t//soldier\tmapp[4][1][0]=7,mapp[4][3][0]=7,mapp[4][5][0]=7,mapp[4][7][0]=7,mapp[4][9][0]=7;\t\t//Red\t//underline character\tmapp[10][1][1]=5,mapp[10][2][1]=4,mapp[10][3][1]=3,mapp[10][4][1]=2,mapp[10][5][1]=1;\tmapp[10][6][1]=2,mapp[10][7][1]=3,mapp[10][8][1]=4,mapp[10][9][1]=5;\t//duck\tmapp[8][1][1]=6,mapp[8][9][1]=6;\t//soldier\tmapp[7][1][1]=7,mapp[7][3][1]=7,mapp[7][5][1]=7,mapp[7][7][1]=7;mapp[7][9][1]=7;\t&#125;void attack(int x1,int y1,int x2,int y2,int from,int to)&#123;\t\tmapp[x2][y2][from]=mapp[x1][y1][from];\t\tmapp[x1][y1][from]=0;\t\tif(to!=-1)mapp[x2][y2][to]=0;&#125;int getgroup(int x,int y)&#123;\tif(mapp[x][y][0])return 0;\telse if(mapp[x][y][1])return 1;\telse return -1;&#125;Node getcaptain(int gr)&#123;\tNode t;\tfor(int i=1;i&lt;=10;i++)&#123;\t\tfor(int j=1;j&lt;=9;j++)&#123;\t\t\tif(mapp[i][j][gr]==1)&#123;\t\t\t\tt.x=i,t.y=j;\t\t\t\treturn t;\t\t\t&#125;\t\t&#125;\t&#125;&#125;bool captain(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint tx=abs(x1-x2),ty=abs(y1-y2);\tif(tx==1&amp;&amp;ty==0)return true;\telse if(tx==0&amp;&amp;ty==1)return true;\telse return false;&#125;bool guard(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint tx=abs(x1-x2),ty=abs(y1-y2);\tif(tx==1&amp;&amp;ty==1)\treturn true;\telse return false;&#125;bool elephant(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint aimx[4]=&#123;-2,-2,2,2&#125;,aimy[4]=&#123;-2,2,-2,2&#125;;\tint stx[4]=&#123;-1,-1,1,1,&#125;,sty[4]=&#123;-1,1,-1,1&#125;;\tfor(int i=0;i&lt;4;i++)&#123;\t\tint tx=x1+aimx[i],ty=y1+aimy[i];\t\tif(tx==x2&amp;&amp;ty==y2)&#123;\t\t\tint ttx=x1+stx[i],tty=y1+sty[i];\t\t\tif(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;bool horse(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint aimx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,aimy[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;;\tint stx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,sty[8]=&#123;0,0,1,1,0,0,-1,-1&#125;;\tfor(int i=0;i&lt;8;i++)&#123;\t\tint tx=x1+aimx[i],ty=y1+aimy[i];\t\tif(tx==x2&amp;&amp;ty==y2)&#123;\t\t\tint ttx=x1+stx[i],tty=y1+sty[i];\t\t\tif(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;bool car(int x1,int y1,int x2,int y2,int from,int to)&#123;\tif(x1!=x2&amp;&amp;y1!=y2)return false;\tif(x1==x2)&#123;\t\tfor(int i=min(y1,y2)+1;i&lt;=max(y1,y2)-1;i++)&#123;\t\t\tif(mapp[x1][i][0]||mapp[x1][i][1])\t\t\t\treturn false;\t\t&#125;\t&#125;\tif(y1==y2)&#123;\t\tfor(int i=min(x1,x2)+1;i&lt;=max(x1,x2)-1;i++)&#123;\t\t\tif(mapp[i][y1][0]||mapp[i][y1][1])&#123;\t\t\t\treturn false;\t\t\t&#125;\t\t&#125;\t&#125;\treturn true;&#125;bool duck(int x1,int y1,int x2,int y2,int from,int to)&#123;\tint aimx[8]=&#123;-3,-3,-2,2,3,3,2,-2&#125;,aimy[8]=&#123;-2,2,3,3,2,-2,-3,-3&#125;;\tint stx[8]=&#123;-2,-2,-1,1,2,2,1,-1&#125;,sty[8]=&#123;-1,1,2,2,1,-1,-2,-2&#125;;\tint subx[8]=&#123;-1,-1,0,0,1,1,0,0&#125;,suby[8]=&#123;0,0,1,1,0,0,-1,-1&#125;;\tfor(int i=0;i&lt;8;i++)&#123;\t\tint tx=x1+aimx[i],ty=y1+aimy[i];\t\tif(tx==x2&amp;&amp;ty==y2)&#123;\t\t\tint ttx=x1+stx[i],tty=y1+sty[i];\t\t\tint tttx=x1+subx[i],ttty=y1+suby[i];\t\t\tif(mapp[ttx][tty][0]==0&amp;&amp;mapp[ttx][tty][1]==0&amp;&amp;mapp[tttx][ttty][0]==0&amp;&amp;mapp[tttx][ttty][1]==0)&#123;\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;bool soldier(int x1,int y1,int x2,int y2,int from,int to)&#123;\tif(captain(x1,y1,x2,y2,from,to))return true;\tif(guard(x1,y1,x2,y2,from,to))return true;\treturn false;&#125;bool cankill()&#123;\tNode blue,red;\tblue=getcaptain(0),red=getcaptain(1);\tfor(int i=1;i&lt;=10;i++)&#123;\t\tfor(int j=1;j&lt;=9;j++)&#123;\t\t\tif(mapp[i][j][0])&#123;\t\t\t\tif(mapp[i][j][0]==1)\t\t\t\t\tif(captain(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==2)\t\t\t\t\tif(guard(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==3)\t\t\t\t\tif(elephant(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==4)\t\t\t\t\tif(horse(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==5)\t\t\t\t\tif(car(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==6)\t\t\t\t\tif(duck(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][0]==7)\t\t\t\t\tif(soldier(i,j,red.x,red.y,0,1))\t\t\t\t\t\treturn true;\t\t\t&#125;\t\t\tif(mapp[i][j][1])&#123;\t\t\t\tif(mapp[i][j][1]==1)\t\t\t\t\tif(captain(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==2)\t\t\t\t\tif(guard(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==3)\t\t\t\t\tif(elephant(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==4)\t\t\t\t\tif(horse(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==5)\t\t\t\t\tif(car(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==6)\t\t\t\t\tif(duck(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t\tif(mapp[i][j][1]==7)\t\t\t\t\tif(soldier(i,j,blue.x,blue.y,1,0))\t\t\t\t\t\treturn true;\t\t\t&#125;\t\t&#125;\t&#125;\treturn false;&#125;bool isend()&#123;\t\tint t=0;\tfor(int k=0;k&lt;=1;k++)&#123;\t\tfor(int i=1;i&lt;=10;i++)&#123;\t\t\tfor(int j=1;j&lt;=9;j++)&#123;\t\t\t\tif(mapp[i][j][k]==1)t++;\t\t\t&#125;\t\t&#125;\t&#125;\tif(t&lt;2)&#123;\t\tflg=1;\t\treturn true;\t\t&#125;\telse return false;\t&#125;void print(int M_C,int M_G,int K_C,int K_G,int canmove)&#123;\t//canmove?\tif(canmove==1)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\troun=1-roun;\t\t//End?\tif(isend())&#123;\t\tcout&lt;&lt;&quot;no;yes&quot;&lt;&lt;endl;\t\t&#125;\telse \t&#123;\t\tif(cankill())cout&lt;&lt;&quot;yes;&quot;;\t\telse cout&lt;&lt;&quot;no;&quot;;\t\tcout&lt;&lt;&quot;no&quot;&lt;&lt;endl;\t&#125;&#125;void move(int x1,int y1,int x2,int y2,int from,int to)&#123;\t//nowgame();\t\tif(from!=roun)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t//check the size\tif(x1&lt;1||x2&lt;1||x1&gt;10||x2&gt;10||y1&lt;1||y2&lt;1||y1&gt;9||y2&gt;9)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//check the gruops\tif(from==to)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//check the from\tif(from==-1)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//check if the game is over\tif(flg==1)&#123;\t\tcout&lt;&lt;&quot;Invalid command&quot;&lt;&lt;endl;\t\treturn;\t&#125;\t\t//captain\tif(mapp[x1][y1][from]==1)&#123;\t\tif(captain(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t//guard\tif(mapp[x1][y1][from]==2)&#123;\t\tif(guard(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t\t\t//elephant\tif(mapp[x1][y1][from]==3)&#123;\t\tif(elephant(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t\t\t//horse\tif(mapp[x1][y1][from]==4)&#123;\t\tif(horse(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t//car\tif(mapp[x1][y1][from]==5)&#123;\t\tif(car(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t//duck\t\t\tif(mapp[x1][y1][from]==6)&#123;\t\tif(duck(x1,y1,x2,y2,from,to))&#123;\t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t\t\t//soldier\tif(mapp[x1][y1][from]==7)&#123;\t\t\tif(soldier(x1,y1,x2,y2,from,to))&#123; \t\t\tint ta=mapp[x1][y1][from];\t\t\tint tb=mapp[x2][y2][to];\t\t\tcout&lt;&lt;group[from]&lt;&lt;&#x27; &#x27;&lt;&lt;name[ta]&lt;&lt;&#x27;;&#x27;;\t\t\tif(to==-1)cout&lt;&lt;&quot;NA;&quot;;\t\t\telse cout&lt;&lt;group[to]&lt;&lt;&#x27; &#x27;&lt;&lt;name[tb]&lt;&lt;&#x27;;&#x27;; \t\t\t\tattack(x1,y1,x2,y2,from,to);\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,0);\t\t&#125;\t\t\t\t\telse\t\t\tprint(mapp[x1][y1][from],from,mapp[x2][y2][to],to,1);\t&#125;\t\t&#125;int main()&#123;\tbegining();\tcin&gt;&gt;Q;\tfor(int i=1;i&lt;=Q;i++)&#123;\t\tint x1,y1,x2,y2;\t\tcin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;\t\tx1++,y1++,x2++,y2++;\t\tmove(x1,y1,x2,y2,getgroup(x1,y1),getgroup(x2,y2));\t&#125;\t\treturn 0;&#125;","categories":["竞赛解法"]},{"title":"U盘里的文件夹突然变成了“应用程序”后缀名怎么办？","url":"/2021/11/12/file-exe/","content":"最近学校电脑有很多老师喜欢使用U盘拷贝文件，但是我发现，许多老师的U盘都被感染上了病毒。这种病毒很常见，感染力极强，而且甚至像360系软件等等根本无法查杀。那么，这种病毒如何查杀呢？\n1.病毒介绍文件夹EXE病毒，学名Worm.Win32.AutoRun.soq。这种病毒只会运行在win32系统上。当你把你的U盘插入到一台电脑后，突然发现U盘内生成了以文件夹名字命名的文件，扩展名为exe，并且它们的图标跟windows默认的文件夹图标是一样的，很具有迷惑性。当你双击这个被伪装的exe文件后，木马自动启动并在电脑内下毒。\n2.运作原理简而言之，这个病毒就是将你原有的文件夹隐藏起来，然后制造一个exe文件伪装成你的文件夹，其实这个exe就是病毒。在“组织”中，勾选“显示被隐藏的文件和文件夹”，并且取消勾选“隐藏被保护的文件夹”即可看到你的文件夹。\n完整病毒机理：\n病毒运行后会释放以下文件：\ncom.run dp1.fne eAPI.fne internet.fnekrnln.fnrog.dllog.edt RegEx.fnrfne spec.fne ul.dllXP-290F2C69.EXE（后8位随机）\n\n这些文件会被复制到系统盘的C:\\WINDOWS\\system32里面\n随后，新增以下注册表项，以达到病毒随系统启动而自启动的目的。\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\n注册表值：XP-290F2C69（后8位随机）\n类型：REG_SZ\n值：C:\\WINDOWS\\system32\\XP-290F2C69.EXE（后8位随机）\n添加以下启动项，实现病毒自启动：“C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动” 里的“　.lnk”指向病毒文件。\n下载病毒文件： （16,896 字节）保存为以下文件，并且运行它们：%Windir%\\System32\\winvcreg.exe\n%Windir%\\System32\\2080.EXE (名称随机)\n然后，被感染的电脑接入移动磁盘后，病毒会遍历移动磁盘根目录下的文件夹，衍生自身到移动磁盘根目录下，更名为检测到的文件夹名称，修改原文件夹属性为隐藏，使用户在其他计算机使用移动磁盘打开其文件夹时运行病毒， 以达到病毒随移动磁盘传播的目的。\n3.解决办法：1.杀毒软件360并不能查清此病毒，建议使用毒霸或者电脑管家查杀。注意，该方法只能清除病毒，但不能显示被隐藏的文件夹。\n2.手工清除1、结束病毒进程。打开任务管理器，选择进程，结束进程XP-290F2C69.EXE（后8位随机），winvcreg.exe，2080.exe（随机名）。\n2、删除病毒在System32生成的以下文件：\ncom.run dp1.fne eAPI.fne internet.fne krnln.fnr og.dll og.edt RegEx.fnr fne spec.fne ul.dll XP-290F2C69.EXE winvcreg.exe 2080.EXE（随机名）\n3、删除病毒的启动项，删除以下启动项：\n“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run”里的XP-290F2C69.EXE（后8位随机）\n“C:\\Documents and Settings\\Administrator\\「开始」菜单\\程序\\启动” 里的“　.lnk”\n4、清除你的点击“开始”—输入“cmd” ，进入命令提示符，然后进入你U盘所在的根目录，具体操作如下，比如你的U盘盘符位G(即你的U盘在G盘），那么依次运行如下命令（第一行的“G:”为你的U盘盘符）：\n注意：第二句话会删除根目录下包括非病毒在内的所有exe文件，谨慎使用，可以仅使用1、3句话然后手动删除exe文件夹\ncd /d G:for /f &quot;delims=&quot; %a in (&#x27;dir /b /ad&#x27;) do (del /a /f /q &quot;%a.exe&quot;) for /f &quot;delims=&quot; %a in (&#x27;dir /b /adh&#x27;) do (attrib -s -h -r &quot;%a&quot;)\n\n这一步也可以用C++来代替：（不会清除其他文件）\n首先删除你跟目录下所有exe文件夹，随后使用此代码：\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;windows.h&gt;\n\nvoid listFiles(const char * dir);\n\nint main()\n&#123;\n    using namespace std;\n    char dir[100];\n    cout &lt;&lt; &quot;Enter a directory (ends with \\&#39;\\\\\\&#39;): &quot;;\n    cin.getline(dir, 100);\n    strcat(dir, &quot;*.*&quot;);   \n    listFiles(dir);\n    return 0;\n&#125;\n\nvoid listFiles(const char * dir)\n&#123;\n    using namespace std;\n    HANDLE hFind;\n    WIN32_FIND_DATA findData;\n    LARGE_INTEGER size;\n    hFind = FindFirstFile(dir, &amp;findData);\n    if (hFind == INVALID_HANDLE_VALUE)\n    &#123;\n        cout &lt;&lt; &quot;Failed to find first file!\\n&quot;;\n        return;\n    &#125;\n    do\n    &#123;\n        if (strcmp(findData.cFileName, &quot;.&quot;) == 0 || strcmp(findData.cFileName, &quot;..&quot;) == 0)\n            continue;\n        if (findData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)  \n        &#123;\n            cout &lt;&lt; findData.cFileName &lt;&lt; &quot;\\t&lt;dir&gt;\\n&quot;;\n             string str=&quot;attrib \\&quot;&quot;;\n            str.append(findData.cFileName);\n            str.append(&quot;\\&quot; -s -h&quot;);\n            system(str.c_str());\n            \n        &#125;\n        else\n        &#123;\n            size.LowPart = findData.nFileSizeLow;\n            size.HighPart = findData.nFileSizeHigh;\n            cout &lt;&lt; findData.cFileName &lt;&lt; &quot;\\t&quot; &lt;&lt; size.QuadPart &lt;&lt; &quot; bytes\\n&quot;;\n        &#125;\n    &#125; while (FindNextFile(hFind, &amp;findData));\n    cout &lt;&lt; &quot;Done!\\n&quot;;\n    system(&quot;Pause&quot;);\n&#125;\n\n输入你U盘所在盘符（例如 G:\\) （\\要反斜杠）即可\n\n","categories":["日常经验"]},{"title":"GitHub下载速度太慢怎么办？","url":"/2021/08/29/github-speed-up-download/","content":"在本站中，有一些下载项目是我通过GitHub仓库上传的（下载地址：billmarepo.github.io）,但是GitHub在中国大陆地区访问较慢，下载速度更是令人感慨（但是亲测速度比百度网盘快）。那么，在下载本站资源时遇到GitHub下载太慢该如何处置？\n1.复制找到下载的资源，右击选择：复制目标链接（反正就这个意思，不同浏览器显示不同）。\n2.GitHub文件加速利用 Cloudflare Workers 对 github release 、archive 以及项目文件进行加速，部署无需服务器且自带CDN.https://gh.api.99988866.xyzhttps://ghproxy.com/以上网站为演示站点，如无法打开可以查看开源项目：gh-proxy-GitHub 文件加速自行部署。\n3.Github 加速下载将你复制的链接到以下网址就可以加速下载了！\n地址：http://toolwa.com/github/\n4.其他友情链接官网镜像（可以用来clone push等,但是不能登录）https://github.com.cnpmjs.org/\nhttps://hub.fastgit.org/ （速度最快）\nhttps://github.wuyanzheshui.workers.dev/\nAPI镜像（用来api操作）https://api.git.sdut.me/\nhttps://v2.kkpp.cc/\n","categories":["日常经验"],"tags":["github"]},{"title":"世界最大同性交友网站七夕再搞事————remote  ：Support for password authentication was removed on August 13, 2021.","url":"/2021/08/15/github-tokenerror/","content":"原创文章，转载注明出处！\n1.问题背景-background如果你在七夕（没错就是2021年8月14日）的这一天去访问了全球最大的同性交友网站，又刚好去更新提交代码，或者你创建了一个新的仓库送给自己，又刚好想把这个仓库送给github，你就刚好会遇到这个问题：remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead.大概意思就是你原先的密码凭证从2021年8月13日开始就不能用了，必须使用个人访问令牌（personal access token），就是把你的密码替换成token！\n滚！我tm懒得弄！\n \n Github 官方解释\n\nWe described our motivation as we announced similar changes to authenticating with the API as follows:\n\n\nIn recent years, GitHub customers have benefited from a number of security enhancements to GitHub.com, such as two-factor authentication, sign-in alerts, verified devices, preventing the use of compromised passwords, and WebAuthn support. These features make it more difficult for an attacker to take a password that’s been reused across multiple websites and use it to try to gain access to your GitHub account. Despite these improvements, for historical reasons customers without two-factor authentication enabled have been able to continue to authenticate Git and API operations using only their GitHub username and password.\n\n\nBeginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations and will require the use of token-based authentication, such as a personal access token (for developers) or an OAuth or GitHub App installation token (for integrators) for all authenticated Git operations on GitHub.com. You may also continue using SSH keys where you prefer.\n\n\nTokens offer a number of security benefits over password-based authentication:\n\n\n1.Unique – tokens are specific to GitHub and can be generated per use or per device\n\n\n2.Revocable – tokens can can be individually revoked at any time without needing to update unaffected credentials\n\n\n3.Limited – tokens can be narrowly scoped to allow only the access necessary for the use case\n\n\n4.Random – tokens are not subject to the types of dictionary or brute force attempts that simpler passwords that you need to remember or enter regularly might be\n\n大概意思就是：为了保证各位程序员的账户安全，我们已于2021年7月14日禁止大家在git及第三方应用上通过密码授权GitHub。以后将使用token令牌代替密码。（话说能活跃在全球最大同性交友网站的程序猿能有什么秘密值得如此加密。。。）\n2.什么是token令牌？token令牌相当于在第三方接口代替你密码的一个玩意，有点像强密码。但是，token令牌并不是只能有唯一一个的。你可以拥有多个令牌，给不同的第三方接口不同的令牌，而每个令牌都被赋予了不同的权限和使用期限。也就是说，在令牌没赋予的权利将不会给第三方接口和git。当然，token令牌在你设定的期限之后，对应的第三方接口和git就需要你重新给一个令牌，否则也无法使用。令牌也可以随时更改权限和删除。\n3.如何申请token令牌？登陆你的GitHub（注意，在github.com登录你的账户时还是用你的密码，不是令牌) 点击头像。随后点击settings。\n\n往下拉，你会在左侧看到一个Developer settings。点击它。\n\n左侧有Personal access tokens。点击它。\n\n点击右侧generate new token。\n\nNote是你令牌的名称（不是令牌密码），随便填一个。\nexpiration是令牌有效期限。No expiration代表永久令牌。\n下面是选择相应的权限。一般就选择repo 和delete_repo，其他按需勾选。\n拉到最下面，点击generate token，随后跳出来一个界面，有一串绿底字符串即为你的token令牌。\n\n警告！！在这里你一定要将其复制并保存好！建议新建一个txt文件将令牌放入其中！因为这个令牌只会出现一次，你关闭了这个网页，以后GitHub就再也不会告诉你这个令牌了！妥善保管！（妥善保管！两情若是久长时，又岂在朝朝暮暮？）\n返回刚才的界面，你可以查看已经创建的token和给予的权限与有效期。你可以随时更改，管理，删除它们（但是不会显示该令牌）。\n\n随后回到你的git或第三方接口，账号还是输入你的username(用户名)，password就输入你复制的令牌。随后登陆就成功了。\n果然，全球最大的同性交流网站不是吹的，大七夕节非得找个伴侣，它要过七夕谁也拦不住呀！","categories":["日常经验"]},{"title":"最长公共子串问题的后缀数组","url":"/2021/08/26/lcs-suffix-array/","content":"最长公共子串最长公共子串(Longest Common Substring ,简称LCS)问题，是指求给定的一组字符串长度最大的共有的子串的问题。例如字符串”abcb”,“bca”,“acbc”的LCS就是”bc”。\n求多串的LCS，显然穷举法是极端低效的算法。改进一些的算法是用一个串的每个后缀对其他所有串进行部分匹配，用KMP算法，时间复杂度为O(NL^2)，其中N为字符串个数，L为每个串的长度。更优秀的有广义后缀树的方法，时间可以达到 O(NL)。本文介绍一种基于后缀数组的LCS解法，利用二分查找技术，时间复杂度可以达到O(NLlogL)。\n最长公共子串问题的后缀数组解法关于后缀数组的构建方法以及Height数组的性质，本文不再具体介绍，可以参阅IOI国家集训队2004年论文《后缀数组》(许智磊)和IOI国家集训队2009年论文《后缀数组——处理字符串的有力工具》(罗穗骞)。\n回顾一下后缀数组，SA[i]表示排名第i的后缀的位置，Height[i]表示后缀SA[i]和SA[i-1]的最长公共前缀(Longest Common Prefix,LCP)，简记为Height[i]&#x3D;LCP(SA[i],SA[i-1])。连续的一段后缀SA[i..j]的最长公共前缀，就是H[i-1..j]的最小值，即LCP(SA[i..j])&#x3D;Min(H[i-1..j])。\n求N个串的最长公共子串，可以转化为求一些后缀的最长公共前缀的最大值，这些后缀应分属于N个串。具体方法如下：\n设N个串分别为S1,S2,S3,…,SN，首先建立一个串S，把这N个串用不同的分隔符连接起来。S&#x3D;S1[P1]S2[P2]S3…SN-1[PN-1]SN，P1,P2,…PN-1应为不同的N-1个不在字符集中的字符，作为分隔符(后面会解释为什么)。\n接下来，求出字符串S的后缀数组和Height数组，可以用倍增算法，或DC3算法。\n然后二分枚举答案A，假设N个串可以有长度为A的公共字串，并对A的可行性进行验证。如果验证A可行，A’(A’&lt; A)也一定可行，尝试增大A，反之尝试缩小A。最终可以取得A的最大可行值，就是这N个串的最长公共子串的长度。可以证明，尝试次数是O(logL)的。\n于是问题就集中到了，如何验证给定的长度A是否为可行解。方法是，找出在Height数组中找出连续的一段Height[i..j]，使得i&lt;&#x3D;k&lt;&#x3D;j均满足Height[k]&gt;&#x3D;A，并且i-1&lt;&#x3D;k&lt;&#x3D;j中，SA[k]分属于原有N个串S1..SN。如果能找到这样的一段，那么A就是可行解，否则A不是可行解。\n具体查找i..j时，可以先从前到后枚举i的位置，如果发现Height[i]&gt;&#x3D;A，则开始从i向后枚举j的位置，直到找到了Height[j+1] &lt; A，判断[i..j]这个区间内SA是否分属于S1..SN。如果满足，则A为可行解，然后直接返回，否则令i&#x3D;j+1继续向后枚举。S中每个字符被访问了O(1)次，S的长度为NL+N-1，所以验证的时间复杂度为O(NL)。\n到这里，我们就可以理解为什么分隔符P1..PN-1必须是不同的N-1个不在字符集中的字符了，因为这样才能保证S的后缀的公共前缀不会跨出一个原有串的范围。\n后缀数组是一种处理字符串的强大的数据结构，配合LCP函数与Height数组的性质，后缀数组更是如虎添翼。利用后缀数组，容易地求出了多个串的LCS，而且时空复杂度也相当优秀了。虽然比起后缀树的解法有所不如，但其简明的思路和容易编程的特点却在实际的应用中并不输于后缀树。\n","categories":["编程算法"]},{"title":"我的第一篇博客","url":"/2021/07/10/myfirstblog/","content":"首先,欢迎各位到访我的空间一直没时间打理这个博客,时至今日,终于在凌晨从百忙中完成了我的第一篇博客.这就算我的第一篇博客吧.\n \n"},{"title":"python之matplotlib详细教程","url":"/2021/08/26/python-matplotlib/","content":"安装前提：你已经安装了python并且在安装时勾选了Add Python to PATH\n打开cmd，输入如下指令：（不要复制粘贴）\npip install matplotlibpip install numpy\n\n安装完后打开python，就可以开始了！\n头文件import matplotlib.pyplot as pltimport numpy as np\n\n1请求一个新的figure对象plt.figure()\n\n1.2Axes在拥有Figure对象之后，在作画前我们还需要轴，没有轴的话就没有绘图基准，所以需要添加Axes。也可以理解成为真正可以作画的纸。\nfig = plt.figure()ax = fig.add_subplot(111)ax.set(xlim=[0.5, 4.5], ylim=[-2, 8], title=&#x27;An Example Axes&#x27;,       ylabel=&#x27;Y-Axis&#x27;, xlabel=&#x27;X-Axis&#x27;)plt.show()\n\n上的代码，在一幅图上添加了一个Axes，然后设置了这个Axes的X轴以及Y轴的取值范围（这些设置并不是强制的，后面会再谈到关于这些设置）\n对于上面的fig.add_subplot(111)就是添加Axes的，参数的解释的在画板的第1行第1列的第一个位置生成一个Axes对象来准备作画。也可以通过fig.add_subplot(2, 2, 1)的方式生成Axes，前面两个参数确定了面板的划分，例如 2， 2会将整个面板划分成 2 * 2 的方格，第三个参数取值范围是 [1, 2*2] 表示第几个Axes。如下面的例子：\nfig = plt.figure()ax1 = fig.add_subplot(221)ax2 = fig.add_subplot(222)ax3 = fig.add_subplot(224)\n\n1.3 Multiple Axes可以发现我们上面添加 Axes 似乎有点弱鸡，所以提供了下面的方式一次性生成所有 Axes：\nfig, axes = plt.subplots(nrows=2, ncols=2)axes[0,0].set(title=&#x27;Upper Left&#x27;)axes[0,1].set(title=&#x27;Upper Right&#x27;)axes[1,0].set(title=&#x27;Lower Left&#x27;)axes[1,1].set(title=&#x27;Lower Right&#x27;)\n\nfig 还是我们熟悉的画板， axes 成了我们常用二维数组的形式访问，这在循环绘图时，额外好用。\n1.4 Axes Vs .pyplot相信不少人看过下面的代码，很简单并易懂，但是下面的作画方式只适合简单的绘图，快速的将图绘出。在处理复杂的绘图工作时，我们还是需要使用 Axes 来完成作画的。\nplt.plot([1, 2, 3, 4], [10, 20, 25, 30], color=&#x27;lightblue&#x27;, linewidth=3)plt.xlim(0.5, 4.5)plt.show()\n\n2. 基本绘图2D2.1 线plot()函数画出一系列的点，并且用线将它们连接起来。看下例子：\nx = np.linspace(0, np.pi)y_sin = np.sin(x)y_cos = np.cos(x)ax1.plot(x, y_sin)ax2.plot(x, y_sin, &#x27;go--&#x27;, linewidth=2, markersize=12)ax3.plot(x, y_cos, color=&#x27;red&#x27;, marker=&#x27;+&#x27;, linestyle=&#x27;dashed&#x27;)\n\n在上面的三个Axes上作画。plot，前面两个参数为x轴、y轴数据。ax2的第三个参数是 MATLAB风格的绘图，对应ax3上的颜色，marker，线型。\n另外，我们可以通过关键字参数的方式绘图，如下例：\nx = np.linspace(0, 10, 200)data_obj = &#123;&#x27;x&#x27;: x,            &#x27;y1&#x27;: 2 * x + 1,            &#x27;y2&#x27;: 3 * x + 1.2,            &#x27;mean&#x27;: 0.5 * x * np.cos(2*x) + 2.5 * x + 1.1&#125;fig, ax = plt.subplots()#填充两条线之间的颜色ax.fill_between(&#x27;x&#x27;, &#x27;y1&#x27;, &#x27;y2&#x27;, color=&#x27;yellow&#x27;, data=data_obj)# Plot the &quot;centerline&quot; with `plot`ax.plot(&#x27;x&#x27;, &#x27;mean&#x27;, color=&#x27;black&#x27;, data=data_obj)plt.show()\n\n发现上面的作图，在数据部分只传入了字符串，这些字符串对一个这 data_obj 中的关键字，当以这种方式作画时，将会在传入给 data 中寻找对应关键字的数据来绘图。\n2.2 散点图只画点，但是不用线连接起来。\nx = np.arange(10)y = np.random.randn(10)plt.scatter(x, y, color=&#x27;red&#x27;, marker=&#x27;+&#x27;)plt.show()\n\n2.3 条形图条形图分两种，一种是水平的，一种是垂直的，见下例子：\nnp.random.seed(1)x = np.arange(5)y = np.random.randn(5)fig, axes = plt.subplots(ncols=2, figsize=plt.figaspect(1./2))vert_bars = axes[0].bar(x, y, color=&#x27;lightblue&#x27;, align=&#x27;center&#x27;)horiz_bars = axes[1].barh(x, y, color=&#x27;lightblue&#x27;, align=&#x27;center&#x27;)#在水平或者垂直方向上画线axes[0].axhline(0, color=&#x27;gray&#x27;, linewidth=2)axes[1].axvline(0, color=&#x27;gray&#x27;, linewidth=2)plt.show()\n\n条形图还返回了一个Artists 数组，对应着每个条形，例如上图 Artists 数组的大小为5，我们可以通过这些 Artists 对条形图的样式进行更改，如下例：\nfig, ax = plt.subplots()vert_bars = ax.bar(x, y, color=&#x27;lightblue&#x27;, align=&#x27;center&#x27;)# We could have also done this with two separate calls to `ax.bar` and numpy boolean indexing.for bar, height in zip(vert_bars, y):    if height &lt; 0:        bar.set(edgecolor=&#x27;darkred&#x27;, color=&#x27;salmon&#x27;, linewidth=3)plt.show()\n\n2.4 直方图直方图用于统计数据出现的次数或者频率，有多种参数可以调整，见下例：\nnp.random.seed(19680801)n_bins = 10x = np.random.randn(1000, 3)fig, axes = plt.subplots(nrows=2, ncols=2)ax0, ax1, ax2, ax3 = axes.flatten()colors = [&#x27;red&#x27;, &#x27;tan&#x27;, &#x27;lime&#x27;]ax0.hist(x, n_bins, density=True, histtype=&#x27;bar&#x27;, color=colors, label=colors)ax0.legend(prop=&#123;&#x27;size&#x27;: 10&#125;)ax0.set_title(&#x27;bars with legend&#x27;)ax1.hist(x, n_bins, density=True, histtype=&#x27;barstacked&#x27;)ax1.set_title(&#x27;stacked bar&#x27;)ax2.hist(x,  histtype=&#x27;barstacked&#x27;, rwidth=0.9)ax3.hist(x[:, 0], rwidth=0.9)ax3.set_title(&#x27;different sample sizes&#x27;)fig.tight_layout()plt.show()\n\n参数中density控制Y轴是概率还是数量，与返回的第一个的变量对应。histtype控制着直方图的样式，默认是 ‘bar’，对于多个条形时就相邻的方式呈现如子图1， ‘barstacked’ 就是叠在一起，如子图2、3。 rwidth 控制着宽度，这样可以空出一些间隙，比较图2、3. 图4是只有一条数据时。\n2.5 饼图labels = &#x27;Frogs&#x27;, &#x27;Hogs&#x27;, &#x27;Dogs&#x27;, &#x27;Logs&#x27;sizes = [15, 30, 45, 10]explode = (0, 0.1, 0, 0)  # only &quot;explode&quot; the 2nd slice (i.e. &#x27;Hogs&#x27;)fig1, (ax1, ax2) = plt.subplots(2)ax1.pie(sizes, labels=labels, autopct=&#x27;%1.1f%%&#x27;, shadow=True)ax1.axis(&#x27;equal&#x27;)ax2.pie(sizes, autopct=&#x27;%1.2f%%&#x27;, shadow=True, startangle=90, explode=explode,    pctdistance=1.12)ax2.axis(&#x27;equal&#x27;)ax2.legend(labels=labels, loc=&#x27;upper right&#x27;)plt.show()\n\n饼图自动根据数据的百分比画饼.。labels是各个块的标签，如子图一。autopct&#x3D;%1.1f%%表示格式化百分比精确输出，explode，突出某些块，不同的值突出的效果不一样。pctdistance&#x3D;1.12百分比距离圆心的距离，默认是0.6.\n2.6 箱形图为了专注于如何画图，省去数据的处理部分。 data 的 shape 为 (n, )， data2 的 shape 为 (n, 3)。\nfig, (ax1, ax2) = plt.subplots(2)ax1.boxplot(data)ax2.boxplot(data2, vert=False) #控制方向\n\n2.7 泡泡图散点图的一种，加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小，如下例：\nnp.random.seed(19680801)N = 50x = np.random.rand(N)y = np.random.rand(N)colors = np.random.rand(N)area = (30 * np.random.rand(N))**2  # 0 to 15 point radiiplt.scatter(x, y, s=area, c=colors, alpha=0.5)plt.show()\n\n2.8 等高线（轮廓图）有时候需要描绘边界的时候，就会用到轮廓图，机器学习用的决策边界也常用轮廓图来绘画，见下例：\nfig, (ax1, ax2) = plt.subplots(2)x = np.arange(-5, 5, 0.1)y = np.arange(-5, 5, 0.1)xx, yy = np.meshgrid(x, y, sparse=True)z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)ax1.contourf(x, y, z)ax2.contour(x, y, z)\n\n上面画了两个一样的轮廓图，contourf会填充轮廓线之间的颜色。数据x, y, z通常是具有相同 shape 的二维矩阵。x, y 可以为一维向量，但是必需有 z.shape &#x3D; (y.n, x.n) ，这里 y.n 和 x.n 分别表示x、y的长度。Z通常表示的是距离X-Y平面的距离，传入X、Y则是控制了绘制等高线的范围。\n3 布局、图例说明、边界等3.1区间上下限当绘画完成后，会发现X、Y轴的区间是会自动调整的，并不是跟我们传入的X、Y轴数据中的最值相同。为了调整区间我们使用下面的方式：\nax.set_xlim([xmin, xmax])   #设置X轴的区间ax.set_ylim([ymin, ymax])   #Y轴区间ax.axis([xmin, xmax, ymin, ymax])   #X、Y轴区间ax.set_ylim(bottom=-10)     #Y轴下限ax.set_xlim(right=25)       #X轴上限\n\nx = np.linspace(0, 2*np.pi)y = np.sin(x)fig, (ax1, ax2) = plt.subplots(2)ax1.plot(x, y)ax2.plot(x, y)ax2.set_xlim([-1, 6])ax2.set_ylim([-1, 3])plt.show()\n\n可以看出修改了区间之后影响了图片显示的效果。\n3.2 图例说明我们如果我们在一个Axes上做多次绘画，那么可能出现分不清哪条线或点所代表的意思。这个时间添加图例说明，就可以解决这个问题了，见下例：\nfig, ax = plt.subplots()ax.plot([1, 2, 3, 4], [10, 20, 25, 30], label=&#x27;Philadelphia&#x27;)ax.plot([1, 2, 3, 4], [30, 23, 13, 4], label=&#x27;Boston&#x27;)ax.scatter([1, 2, 3, 4], [20, 10, 30, 15], label=&#x27;Point&#x27;)ax.set(ylabel=&#x27;Temperature (deg C)&#x27;, xlabel=&#x27;Time&#x27;, title=&#x27;A tale of two cities&#x27;)ax.legend()plt.show()\n\n在绘图时传入 label 参数，并最后调用ax.legend()显示体力说明，对于 legend 还是传入参数，控制图例说明显示的位置：\nLocation String\tLocation Code‘best’\t0‘upper right’\t1‘upper left’\t2‘lower left’\t3‘lower right’\t4‘right’\t5‘center left’\t6‘center right’\t7‘lower center’\t8‘upper center’\t9‘center’\t10\n\n3.3 区间分段默认情况下，绘图结束之后，Axes 会自动的控制区间的分段。见下例：\ndata = [(&#x27;apples&#x27;, 2), (&#x27;oranges&#x27;, 3), (&#x27;peaches&#x27;, 1)]fruit, value = zip(*data)fig, (ax1, ax2) = plt.subplots(2)x = np.arange(len(fruit))ax1.bar(x, value, align=&#x27;center&#x27;, color=&#x27;gray&#x27;)ax2.bar(x, value, align=&#x27;center&#x27;, color=&#x27;gray&#x27;)ax2.set(xticks=x, xticklabels=fruit)#ax.tick_params(axis=&#x27;y&#x27;, direction=&#x27;inout&#x27;, length=10) #修改 ticks 的方向以及长度plt.show()\n\n上面不仅修改了X轴的区间段，并且修改了显示的信息为文本。\n3.4 布局当我们绘画多个子图时，就会有一些美观的问题存在，例如子图之间的间隔，子图与画板的外边间距以及子图的内边距，下面说明这个问题：\nfig, axes = plt.subplots(2, 2, figsize=(9, 9))fig.subplots_adjust(wspace=0.5, hspace=0.3,                    left=0.125, right=0.9,                    top=0.9,    bottom=0.1)#fig.tight_layout() #自动调整布局，使标题之间不重叠plt.show()\n\n通过fig.subplots_adjust()我们修改了子图水平之间的间隔wspace&#x3D;0.5，垂直方向上的间距hspace&#x3D;0.3，左边距left&#x3D;0.125 等等，这里数值都是百分比的。以 [0, 1] 为区间，选择left、right、bottom、top 注意 top 和 right 是 0.9 表示上、右边距为百分之10。不确定如果调整的时候，fig.tight_layout()是一个很好的选择。之前说到了内边距，内边距是子图的，也就是 Axes 对象，所以这样使用 ax.margins(x&#x3D;0.1, y&#x3D;0.1)，当值传入一个值时，表示同时修改水平和垂直方向的内边距。\n调整使他们使用一样的X、Y轴：\nfig, (ax1, ax2) = plt.subplots(1, 2, sharex=True, sharey=True)ax1.plot([1, 2, 3, 4], [1, 2, 3, 4])ax2.plot([3, 4, 5, 6], [6, 5, 4, 3])plt.show()\n\n\n3.5 轴相关改变边界的位置，去掉四周的边框：\nfig, ax = plt.subplots()ax.plot([-2, 2, 3, 4], [-10, 20, 25, 5])ax.spines[&#x27;top&#x27;].set_visible(False)     #顶边界不可见ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)  # ticks 的位置为下方，分上下的。ax.spines[&#x27;right&#x27;].set_visible(False)   #右边界不可见ax.yaxis.set_ticks_position(&#x27;left&#x27;)  # &quot;outward&quot;# 移动左、下边界离 Axes 10 个距离#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;outward&#x27;, 10))#ax.spines[&#x27;left&#x27;].set_position((&#x27;outward&#x27;, 10))# &quot;data&quot;# 移动左、下边界到 (0, 0) 处相交ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# &quot;axes&quot;# 移动边界，按 Axes 的百分比位置#ax.spines[&#x27;bottom&#x27;].set_position((&#x27;axes&#x27;, 0.75))#ax.spines[&#x27;left&#x27;].set_position((&#x27;axes&#x27;, 0.3))plt.show()\n","tags":["python"]},{"title":"C++中如何使用struct和STL创建链表结构","url":"/2021/07/21/stl_use/","content":"一.链表结构的使用1.创建struct node&#123;    int data;//该链数据    node *next;//指向链表下一个数据&#125;node *p;//链表所在的地址\n\n2.新增存储单元p = new node;\n\n3.其他所需的操作符node *head;//指向头节点node *p;//用来申请新的数据单元node *r;//用来指向末节点(最后一个数据)\n\n4.输入一个链表int x;//每次输入的数据scanf(&quot;%d&quot;,&amp;x);while (/*输入链条的终止条件*/)&#123;    p=new node;//申请一个新节点    p-&gt;data=x;//录入数据    p-&gt;next=NULL;//初始化下一个节点避免闪退    r-&gt;next=p;//将新节点接到前面链表中    r=p;//末节点后移    scanf(&quot;%d&quot;,&amp;x);//输入下一个数据&#125;\n\n5.输出链表p=head-&gt;next;//p指针回到链表开头while(p-&gt;next != NULL)&#123;    printf(&quot;%d&quot;,p-&gt;data);    p=p-&gt;next;//到下一个节点&#125;printf(&quot;%d&quot;,p-&gt;data);//把最后一个数据也输出\n\n6.查找某个条件的数据a.查找满足一定条件的节点p=head-&gt;next;while((p-&gt;data !=(满足的条件))&amp;&amp;(p-&gt;next !=NULL))p=p-&gt;next;if(p-&gt;data ==(满足的条件))处理该数据;else 输出不存在;\n\nb.查找所有满足条件的点p=head-&gt;next;while(p-&gt;next != NULL)&#123;    if(p-&gt;data==(满足的条件))&#123;        /*处理该数据*/    &#125;    p=p-&gt;next;&#125;\n\n二.使用STL容器进行a.set1.特点无序，随机，类似于指针（但其实不是指针，STL容器过于强大）\n2.头文件#include &lt;set&gt;using namespace std;\n\n3.定义容器set&lt;kind&gt;name/*例：*/set&lt;string&gt;class_set;//类中的一个学生列表\n\n4.添加元素while(/*满足条件*/)&#123;    string str;    cin&gt;&gt;str;    class_set.insert(str);&#125;\n\n5.输出学生集合（无序的）[1]创建迭代器set&lt;kind&gt;::const_iterator cur_name;//cur_name为迭代器/*example*/set&lt;string&gt;::const_iterator cur_student;\n\n[2]遍历输出for(cur_student = class_set.begin();    cur_student !=class_set.end();    cur_student++)cout&lt;&lt;*cur_student&lt;&lt;endl;\n\n\ncur_student被定义成string类型的迭代器，类似于指针地址\n\n\n初始条件：cur_student指针指向class_set.begin()的地址\n\n\n终止条件：cur_student指针指向class_set.end()的地址\n\n注意：不能将for循环里面的！&#x3D;改成&lt;或者其他符号，因为列表是无序的。++指的是地址后移一位，而不是数字+1\n[3]使用foreach函数进行遍历输出/*1.头文件*/#include &lt;algorithm&gt;/*2.创建输出指令*/static void write(set&lt;string&gt;::const_iterator cur_student)&#123;    cout&lt;&lt;*cur_student&lt;&lt;endl;&#125;/*3.使用foreach进行遍历*/foreach(class_set.begin(),class_set.end(),write);\n\n6.其它set容器当中不能有重复的元素，否则程序会意外终止。如果你想要存放重复元素，你可以将上述set换成multiset即可。\nb.map1.特点不同于set，map有两个值，第一个可以称为关键字(key)，每个关键字只能在map中出现一次；第二个可能称为该关键字的值(value)；\nkey在一个map只能出现一次，但是value可以出现多次。\nkey和value是一对一(one-to-one)的，而不同于set，map是有序对。\n2.头文件#include &lt;map&gt;using namespace std;\n\n3.声明mapstd:map&lt;type1,type2&gt; variable;/*example*/std:map&lt;int,string&gt; person;\n\n当然，如果你觉得每次都定义一个map太烦了，你可以使用typedef\ntypedef map&lt;int,string&gt; mapp;mapp variable1;mapp variable2;...\n\n4.加入元素现在，我们已经声明了一个叫做variable的map容器(你自己随便声明一个也无所谓)。插入有几种方法：\n//First Kind:INSERT function//1.insert+pairvaribale.insert(pair&lt;type1,type2&gt;(key,value));/*example*/variable.insert(pair&lt;int,string&gt;(1,&quot;Bill Gates&quot;));//2.insert+value_typevariable.insert(map&lt;type1,type2&gt;::value_type(key,value));/*example*/variable.insert(map&lt;int,string&gt;::value_type(2,&quot;Jeff Bezos&quot;));//Second Kind:Array[]variable[key]=value;/*example*/variable[3]=&quot;Michael Dell&quot;;\n\n为什么我要分为两种呢？因为使用insert+pair和insert+value_type组合效果是相同的。他俩都是通过insert函数插入数据。但是，如果某key已经有了一个value，insert函数是会自动跳过不执行指令的。如果使用array数组进行插入，新输入的数据就会把原有的数据覆盖住。\n5.查找元素这个时候又要用到迭代器了。先声明一个迭代器iterate，随后循环查找：\niterate = variable.find(key);while(iterate != variable.end())&#123;    /*处理该数据*/&#125;\n\n6.删除元素//1.iterateiterate =variable.find(key);int del =variable.erase(iterate);//erase函数删除成功返回1，否则返回0，下同//2.keyint del =variable.erase(key);//3.delete key1~key2int del =variable.erase(key1,key2);//把key1到key2之间所有的数据全部删除//如果想删除某map所有数据，有以下两种办法：/*1*/int del =variable.erase(variable.begin(),variable.end());/*2*/int del =variable.clear();\n\n7.map大小我怎么知道map里面目前有多少数据呢？\nint num =variable.size();\n\n\n未完待续。。。\n","categories":["编程算法"]},{"title":"wenyan-compile","url":"/2021/10/09/wenyan-compile/","content":"1、说在前面中考总分130分。其中古代诗歌默写6分，文言文阅读11分，古诗鉴赏4分。总共21分。\n古代文学占17.5%\n高考总分150分。文言阅读9分，翻译10分，古诗词鉴赏8分，古诗文默写8分。总共35分。\n古代文学占21.3%\n可见文言文是十分重要的。\n然而。。。你想过用文言文编程吗？？？\n这几年，奇奇怪怪的编程语言逐渐变多，其中一个学霸创建了一个叫文言文的编程语言，风靡github（？\n2、关于wenyan语言的代码与语法2-1、认识wenyan语言咱们都知道，学习一门编程语言是从什么开始的？？\n众OIer orz ：当然是 A+B~\n哦，不对，学习一门语言应该先从理解这个语言的优缺点啊，基础框架啊等等（回想一下你刚开始学 C++ ， Pascal的时候（那时候我C++框架默了5遍都默错））。\n但是! wenyan 语言 没有框架！\nwenyan就像 Pascal一样，定义好变量后就直接开始打主代码了。不会像 C++一样还有什么万能头啊，什么 STL 啊，没有这么多,简单易懂（还能提升你的文言文阅读水平）。\n现在，我们要开始打主代码，我们先从最基本的 Hello world!开始吧~\nwenyan打三遍Hello world! 的输出是这样的：\n吾有一數。曰三。名之曰「甲」。為是「甲」遍。\t吾有一言。曰「「問天地好在。」」。書之。云云\n\n编译为Javascript\nvar n = 3;for (var i = 0; i &lt; n; i++) &#123;    console.log(&quot;問天地好在。&quot;);&#125;\n\n 编译为Python\na=3for _rand1 in range(a):\t_ans1=&quot;問天地好在。&quot;\tprint(_ans1)\n\n 编译为Ruby\na=3a.times do |_rand1|\t_ans1=&quot;問天地好在。&quot;\tp([_ans1].join)end \n\n 自译为c&#x2F;c++\nint n = 3;for (int i=0;i&lt;n;++i) &#123;    printf(&quot;問天地好在。&quot;);&#125;　\n\n运行：\n問天地好在。問天地好在。問天地好在。\n是不是很生动？很形象？对， wenyan 就是这样！清晰易懂，代码简便……\n现在开始介绍 wenyan的基本语法:\n2-2、基本语法2-2-1、定义变量毕竟都说是文言文编程了，肯定不能出现英文字母和数字的嘛~\n吾有一數。曰六。名之曰「甲」。 int a（a就是甲）=6;有數六。名之曰「蒟蒻」。 int juruo=6;吾有一言。曰「「噫吁戲」」。名之曰「乙」。 string b（就是乙）=alas!\n\n2-2-2、ture和falsetrue&#x2F;false 分别对应 wenyan语言中的陽&#x2F;陰（繁体的阳&#x2F;阴），类型就是“爻”（卦符的基本符号）：\nC++吾有一爻。曰陽。名之曰「丙」。 bool c=true;吾有一爻。曰陰。名之曰「丁」。 bool d=false;\n\n2-2-3、if判断作为一个编程语言怎么少了 ifi判断呢？\nC++若三不大於五者。吾有一言。曰「「OK」」。 if(3&lt;=5) cout&lt;&lt;&quot;OK&quot;;書之。。若非。乃得「「NO」」也 else cout&lt;&lt;&quot;NO&quot;;\n\n2-2-4、运算符加减乘除一应俱全，连逻辑运算符都有!\nC++加一以一。 1+1除七以三。所餘幾何。 7%3減六六六六以六六六。名之曰「甲」。 int a=6666-666;\n\n2-2-5 容器类型容器类型也支持，而且注意一下，首个下标是从一开始的。\nC++吾有一列。名之曰「数组」。充「数组」以四。以二。 int shuzu[]=&#123;4,2&#125;;夫「寶劍」之長。 sword.size;夫「蒟蒻」之一。 juruo[1];夫「中国」之「「名」」。 China[&quot;name&quot;]\n\n2-2-6 进价语法一些 wenyan 的进价语法。。。。。。\n定义函数wenyan：吾有一術。名之曰「吸星大法」。是術曰。⋯⋯是謂「吸星大法」之術也。\nfunction f()&#123;...&#125;\n\n定义含参函数wenyan：吾有一術。名之曰「六脈神劍」。欲行是術。必先得六數。曰「甲」。曰「乙」。曰「丙」。曰「丁」。曰「戊」。曰「己」乃行是術曰。⋯⋯是謂「六脈神劍」之術也。\nfunction f(a,b,c,d,e,f)&#123;...&#125;\n\n定义其他函数wenyan：吾有一術。名之曰「翻倍」。欲行是術。必先得一數。曰「甲」。乃行是術曰。乘「甲」以二。名之曰「乙」。乃得「乙」。是謂「翻倍」之術也。\nfunction double(a)&#123;var b = a * 2; return b;&#125;\n\nwenyan：施「翻倍」於「蒟蒻」。\ndouble(juruo);\n\nwenyan：吾有一數。曰五。書之。\nconsole.log(5);\n\n2-2-7 循环就是那些 for ， while循环之类的。（注意！ 云云 为 wenyan语言循环的后面必加的东西！）\n為是百遍。⋯⋯ 云云。 for(int i=1;i&lt;=100;i++)......恆為是。⋯⋯ 云云。 while(true) ......乃止。 break\n\n目前就这些了……\n3、编写wenyan语言程序运行本人是用洛谷 IDE 进行运行的，当然还有一种网站也可以实现 wenyan语言的编译运行，还可以实现 wenyan转 JavaScript和 Python的功能！（虽然我都不会……）这个网站就是：戳这里\n这里面有不少好康和好玩的东西，你也可以在这里面编译。\n而且项目文件还有个脚本src&#x2F;render.js，它可以把程序渲染成古代书籍的样子。\n4、关于wenyan语言编程\n夫唐、虞之世，結繩而足治，屈指而足算。是時豈料百代之後，計算機械之巧，精於公輸之木鳶，善於武侯之流馬；程式語言之多，繁若《天官》之星宿，奇勝《山經》之走獸。鼠、蟹、鑽、魚，或以速稱。蛇、象、駱、犀，各爭文采。方知鬼之所以夜哭，天之所以雨粟。然以文言編程者 ，似所未有。此非文脈之所以傳，文心之所以保。嗟予小子，遂有斯志。然則數寸之烏絲猶覆於頭，萬卷之素書未破於手；一身長羁于远邦，兩耳久旷于雅言。然夫文章者吾之所宿好，程式者偶承時人之謬譽。故希孟不慚年少，莊生不望無涯。乃作斯言。未能嘔瀝長吉之心血，亦庶幾免於義山之流沫。既成之後，復學干將鑄劍而自飼，越王嚐糞而當先。自謂偶追《十書》之筆意，但恨少八家之淋漓。此子山所謂士衡抚掌而甘心，平子見陋而固宜。然則雖實覆甕之質，尚存斧正之望；雖乏呂相之金，易字之渴蓋同。此亦開源之大義，吾輩之所以勉勵也。一笑。 —-Huang Lingdong（wenyan语言作者）\n\nHuang Lingdong，来自卡耐基梅隆大学，如今大四，明年即将毕业。高中则毕业自上海世界外国语中学。\n就是这个小伙子，做出了这个风靡 github的 wenyan语言！\n5、写在最后到最后，不知道大家看懂没（反正我是看懂了）。\n真的是奇葩多。。。\n附录：奇奇怪怪的编程语言EsolangEsoteric programming language，简称 Esolang，它们的设计被用于测试计算机语言设计的极限，作为一个概念的证明，或仅仅是一个玩笑。Esolang 创作者通常并不打算让它成为主流编程语言，他们几乎不会在意语言的可用性，甚至恰恰相反，会故意增加使用难度。（我介绍这个你们自己品）\n比如 Brainfuck，它是在 1993 年被创造的编程语言，语法仅包含八种符号，没有任何单词，用它打印 Hello world 是这样的：\n++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;.\n\n再比如 MarioLANG，它同样只能使用符号，需要使用形似马里奥关卡的语法来书写：\n++++:     &gt;    &gt; +:+:+:+:+:+:+:::::====+    &gt;^=== &quot;&quot;&quot;=================    +:-):(:^= =                   !    =========  =                  #                = !         .+.,:-&lt;                 =###       ======&quot;\n\nParenthesis Hell，言如其名，括号地狱，只能使用括号来书写：\n(()()(()()(()()()()((()()(()(()((()((()()()((()((()()()((()((((()()(()()()()()()(((()(((()((()((((()(((()()(()()((()((()()()((()()(()()()()(()()()()(()()()()(()(())))))))))))))))))))))))))))))))))))))))))))))))))\n"},{"title":"江苏省信息技术合格性考试自制攻略","url":"/2021/12/19/xinxitest-gl/","content":"1.进制转换标准算法十进制—&gt;二进制\n对于整数部分，用被除数反复除以2，除第一次外，每次除以2均取前一次商的整数部分作被除数并依次记下每次的余数。另外，所得到的商的最后一位余数是所求二进制数的最高位。\n对于小数部分，采用连续乘以基数2，并依次取出的整数部分，直至结果的小数部分为0为止。故该法称“乘基取整法”。\n给你一个十进制，比如：6，如果将它转换成二进制数呢？\n10进制数转换成二进制数，这是一个连续除以2的过程：\n把要转换的数，除以2，得到商和余数，\n将商继续除以2，直到商为0。最后将所有余数倒序排列，得到数就是转换结果。\n听起来有些糊涂？结合例子来说明。比如要转换6为二进制数。\n“把要转换的数，除以2，得到商和余数”。\n那么：要转换的数是6， 6 ÷ 2，得到商是3，余数是0。“将商继续除以2,直到商为0……”\n现在商是3，还不是0，所以继续除以2。\n那就： 3 ÷ 2, 得到商是1,余数是1。\n“将商继续除以2，直到商为0……”\n现在商是1，还不是0，所以继续除以2。\n那就： 1 ÷ 2, 得到商是0，余数是1\n“将商继续除以2，直到商为0……最后将所有余数倒序排列”\n好极！现在商已经是0。\n我们三次计算依次得到余数分别是：0、1、1，将所有余数倒序排列，那就是：110了！\n6转换成二进制，结果是110。\n二进制数转换为十进制数\n二进制数第0位的权值是2的0次方，第1位的权值是2的1次方……\n所以，设有一个二进制数：0110 0100，转换为10进制为：\n下面是竖式：\n0110 0100 换算成十进制\n从右往左开始换算\n第0位 0 * 2^0 = 0第1位 0 * 2^1 = 0第2位 1 * 2^2 = 4第3位 0 * 2^3 = 0第4位 0 * 2^4 = 0第5位 1 * 2^5 = 32第6位 1 * 2^6 = 64第7位 0 * 2^7 = 0\n\n得到01100100(2)&#x3D;4+32+64\n偷懒算法打开计算器（在开始里面直接搜计算器），打开后点击左上角的选项，在里面选择“程序员”，选择原始进制，输入数字，然后不要点等号，直接选择你要转换的进制即可。\n2.IPPv4：本质上是四个八位二进制数，为了方便表达改为四个十进制数 ，以 . 隔开，每一个数字取 0-255−255，例如 12.34.56.78。\nIPv6：八个十六进制数，以 : 隔开，主要是防止 IPv4 不够用。\n3.缩写大全局域网：LAN（Local Area Network），小范围的网络，1km 以内传输效率极高，结构简单。\n城域网：MAN（Metropolitan Area Network），数千米至数十千米内。\n广域网：WAN（Wide Area Network），数十千米至数千千米以上。\n随机存储器：RAM（Random Access Memory）。\n只读存储器：ROM（Read Only Memory）。\n万维网：WWW（World Wide Web）。\n文件传输协议：FTP（File Transfer Protocol）。\n简单邮件传输协议：SMTP（Simple Mail Transfer Protocol）。\n对等网络：P2P（peer-t(w)o-peer），音译。\n邮局协议第三版 ：POP3（Post Office Protocol - Version 3）。\n传输控制协议：TCP（Transmission Control Protocol）。\n用户数据报协议：UDP（User Datagram Protocol）。\n交互邮件访问协议：IMAP（Internet Message Access Protocol）。\n超文本传输协议：HTTP（S）（Hyper Text Transfer Prtcl（over Securesocket ayer）），带 “S”的为增加了传输加密和身份认证。\n4.录入程序有时候题目会给你一个程序，让你选出答案。这时候可以录入到Python中进行模拟，可是考试系统是全屏的，无法直接录入，怎么办呢？\n1.打开桌面上的Python IDLE，打开后CTRL+N新建一个文件。2.打开考试系统注意这里：点开考试系统全屏后按住键盘上的Alt按键不要松开，轻点一下tab按键，会出现程序选择的界面。始终不要松开ALT，轻点tab进行选择，直到选择到Python界面，松开alt，你就会发现Python已经浮在了考试系统的上面，然后录入程序即可。\n注意：如果程序最后没有print函数，请自行添加，否则计算结果不会出来的。\n5.音频大小声卡对声音的处理质量可以用三个基本参数来衡量，即采样频率、采样位数和声道数。\n采样频率是指单位时间内的采样次数。采样频率越大，采样点之间的间隔就越小，数字化后得到的声音就越逼真，但相应的数据量就越大。\n采样位数是记录每次采样值数值大小的位数。采样位数通常有8bits或16bits两种，采样位数越大，所能记录声音的变化度就越细腻，相应的数据量就越大。\n声道数是指处理的声音是单声道还是立体声。单声道在声音处理过程中只有单数据流，而立体声则需要左、右声道的两个数据流。显然，立体声的效果要好，但相应的数据量要比单声道的数据量加倍。\n不经过压缩，声音数据量的计算公式为：\n数据量（byte）&#x3D;（采样频率（Hz）×采样位数（bit）×声道数）&#x2F;8\n（其中，单声道的声道数为1，立体声的声道数为2）\n例子：请计算对于5分钟双声道、16位采样位数、44.1kHz采样频率声音的不压缩数据量是多少？\n根据公式：数据量&#x3D;（采样频率×采样位数×声道数×时间）&#x2F;8 Byte(比特)\n得，数据量（MB）&#x3D;[44.1 × 1000 × 16×2×(5×60)] &#x2F;(8×1024×1024)&#x3D;50.47MB\n计算时要注意几个单位的换算细节：\n时间单位换算：1分&#x3D;60秒\n采样频率单位换算：1kHz&#x3D;1000Hz\n数据量单位换算：1MB&#x3D;1024KB&#x3D;1024×1024Byte&#x3D;1048576Byte\n6.图片存贮大小&#x3D;分辨率*位深&#x2F;8\n分辨率&#x3D;宽 x 高（如：1024 x 768,640 x 480）\n位深：如24位，16位，8位\n&#x2F;8计算的是字节数。\n例如：\n一幅图像分辨率：1024*768,24位，则其大小计算如下：\n大小&#x3D;1024*768824&#x2F;8&#x3D;2359296byte&#x3D;2304KB\n"},{"title":"孔子：黑暗王国里的残烛","url":"/2021/10/30/zz_confuzi/","content":"原作者：鲍鹏山，民革成员，文学博士，作家，学者。上海开放大学人文学院教授 ，青海师范大学硕士研究生导师 [2]  、上海交通大学兼职教授。中国作家协会会员、中国孔子基金会学术委员会委员。潜心研究先秦诸子数十年，长期从事中国古代文学研究。\n前言儒家者流。盖出于司徒之官，助人君顺阴阳明教化者也。游文于六经之中，留意于仁义之际，祖述尧舜，宪章文武，宗师仲尼，以重其言，于道最为高。——《汉书·艺文志》\n士不可不弘毅，任重而道远。仁以为己任，不亦重乎！死而后已，不亦远乎！——曾参\n一　　孔子的长相颇怪。“生而圩顶”，就是说，他天生的脑袋畸型，头顶上中间低，四周高，司马贞说，其形状恰像倒过来的屋顶。名之曰丘，固当。不知命相学家是如何解释的。这种头顶是否暗示着承受天地之甘露阳光？孔子自学而成大才，其天赋必然很高。而其身长亦不凡，“九尺有六寸”，这在那时可以说是“硕人”了，“人皆谓之长人而异之”，人人都说他是长人，感到惊异。真正的一个齐鲁大汉。不过，这个“长人”的身影也确实够长了——长到遮蔽了整个民族漫长的历史，—个民族都—直顺着他的倒影前行两干多年了，我们何时才能走出这漫漫的阴影呢?\n　　据司马迁和《孔子家语》的记载，孔子乃是商代“三仁”之一微子的后代。那个有名的“仁义之师”的统帅宋襄公，便是他的十一世祖——难怪他也像宋襄公那样泥古不化，自讨苦吃。用古老的仁义道德去对付现世的流氓强盗，这也是他家族的祖传秘诀吧，只可惜常常不灵。到孔子的六世祖孔父嘉，“五世亲尽，别为公族”，不再属王族，姓也成了“孔”。后来孔父嘉又为人所逼而奔鲁。所以孔子确实是一位“没落贵族”。到他父亲叔梁纥，便是连人丁也很寥落了：正妻连生九女，—妾生子叫孟皮，却又是个跛子。年近七十的叔梁纥大概非常绝望了。但他还要作最后的努力，于是便向颜氏求婚，颜氏少女颜征“从父命”而嫁给了古稀之年的叔梁纥。所以，司马迁说这是“野合”，“野”与“礼”相对，夫妻双方年龄差别太大，不合周礼，所以这婚姻不是“礼合”，而是“野合”。“野合而生孔子”——这实在太有意味了，为什么呢？孔子终其一生都在为“礼坏乐崩”而头疼，而愤怒，而奔走呼号，要人们“克己复礼”，孰料他本人即是个不合礼的产儿呢。如果他的那位老父亲真的克制自己来恢复周礼，可就没有孔子了。真玄哪。要知道，这不合“礼”的产儿，竟是他们这古老家族之链上最辉煌的一环，也是我们这古老民族历史上最辉煌的人物啊！\n　　宋人说，“天不生仲尼，万古长如夜”。好抬杠的李贄就此讽刺道，怪不得孔子出生之前，人们都点着蜡烛走路。我想，话不能这么说，也不是这么说的。我觉得，孔子确实是悬挂在那个遥远古世纪的一盏明灯，他使我们对那个遥远的时代不再觉得晦暗和神秘，他使那时代的人与后代乃至于我们沟通了。我们由他知道，即便在那么一个洪荒时代，也是有阳光普照着而万物不探手段地生机勃勃；那时代也发生着我们今天一样的事情：暴力和弱者的呻吟；混乱和宁静的企望；束缚与挣扎；阴谋与流血；理想碰了钉子；天真遇见邪恶；友情温暖，世态炎凉。在他手订的《诗经》中，我们甚至可以体验到最个性的感受——当那些面孔不一情性各异的个人复活时，那个时代不也就复活了吗？　　孔子生活的时代也真像他所说的，确实是混乱无道。他为之伤心不已：辉煌的“郁郁乎文哉”的周王朝已是日薄西山，伟大的周公早已英魂远逝，他制定的“礼”“乐”也土崩瓦解。“弑君三十六，亡国五十二”，到处都是乱臣贼子，且个个生龙活虎。西周古都废墟上的青草与野黍也一茬一茬地青了又黄，黄了又青，根深而茎壮了，掩埋在草丛中瓦裂的陶器早已流尽了最后一滴汁液。九鼎不知去向，三礼流失民间。东周呢？龟缩在洛邑弹九之地，可怜巴巴地看着那些纵横天下的伯霸诸侯，把九州版图闹得瓜分而豆刮。\n　　无可奈何花落去，还有谁来用红巾翠袖，擦去周王混浊的老泪？连孔子本人都不曾去那里。在这种时候，要“兴灭国，继绝世，举逸民”，真无异于痴人说梦。孔子正是这样的一位痴人。痴人往往缺乏现实感。他的精神就常常脱逸出现实的背景，沉浸在过去的辉煌中，追寻着万物逝去的方向。是的，他一生都在追寻，他周游列国，颠颠簸簸，既是在找人，找一个能实施他主张的人，更是在找过去的影子，找东周昔日的文明昌盛。面对这一伟大帝国的文化废墟，孔子领悟到并承诺了自己的使命！但挽狂澜于既倒，或知其不可而为之，只不过是一种令人钦敬的悲剧精神罢了，他最终还是失败了。当他奔波倦极归来，在一条小河边饮他那匹汗马时，他偶然从平静的流水中惊见自己斑驳的两鬓，“甚矣，吾衰矣”（太惨啦！我已经衰老了！）他顿时心凉如水。这衰弱的老人，他的多少雄心都失败了，多少理想都破灭了。壮志不酬，眺望茫茫无语的宇宙，他心事浩茫。人世渺小，天道无情，青山依旧，哲人其萎。于是，一句意味深长的叹息便如一丝凉风，吹彻古今：“逝者如斯夫！”\n　　我在几千年后的漆黑的夜里写这篇文章时，宛如见到他当初衰弱地站在苍茫高天之下的无情逝水边。那无限凄惶的老人的晚景使我大为感动。于是这篇文章的题目也就一闪而现了：这衰弱的，即将随着时间的流水逝去的老人，不就像黑暗旷野上快要燃尽的一枝蜡烛吗？四面飚风，寒意四逼，这支蜡烛艰难地闪耀……\n　　孔子死后，鲁哀公装模作样地悲痛一番，悼念一番，他写了一篇诔文，似乎感伤得很：“上天太不公平啦。不肯留下一位老人陪我，让我一人在鲁国孤零零的，唉，多么悲痛。”孔子的弟子子贡毫不客气地顶了回去：“生不能用，死而诔之，非礼也！”\n　　其实，对孔子“生不能用”的，岂止—位鲁哀公呢？孔子一生见过不少诸侯，像楚昭王，齐景公，卫灵公……等等，有谁用他呢？天下人事纷纷扬扬，新生事物层出不穷，人人都在玩新花样，搞新名堂，他老先生拿着一把过时的且是万古不变的尺子，东量量，西测测，这也不合“礼”，那也不合“乐”，到处招人惹人，别人对他敬而远之也是很自然的。同时他又像一个蹩脚的推销员，推销过时的、早已更新换代的产品。这产品不是按顾客的需求而设计，而是要以这产品的规格来设计顾客，正如韩非嘲笑他的，不是根据脚的大小来选鞋，而是根据鞋的大小来“削足”。他这么不合时宜，被人拒绝不是很正常的么？子贡以他的经济实力和外交天才，到处为老师打点鼓吹，也没有什么效果。子贡的悲痛心情是可以理解的，但过分责备鲁哀公不能用孔子，就不大合情合理啦。\n二　　痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉！吾从周！”“逝者如斯夫！”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到—种温软，一种熨帖，这实在是让我们大大舒了—口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。\n　　孔子使一些无序的暴力变成了有目的有方向的努力与企望，他使天下英雄入于他的彀中，并带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往往显示出一种蓬蓬勃勃、生机无穷的魅力。春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想，充满激情，充满公理仁德的时代吗？谁开辟了这样的时代？是孔子。非常具有象征意义的是，当孔子和弟子们周游列国的时候，他往往自己驾车——他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天，一脸凄迷与怀疑，只有他永远目光炯炯，自信目标就在前方。\n　　有一次，在一条汤汤而流的小河边他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。　　其中的一个细长个子却不回答子路的询问，而是反问子路：\n　　“那个执缰绳的人是谁？”\n　　子路恭敬地回答：“是孔丘。”\n　　“是鲁国的那个孔丘吗？”——可见孔子的知名度颇高。\n　　子路答：“是”。这个细高个冷冷的就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛”。\n　　没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能按捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁？”\n　　子路仍然是恭敬地回答：“我是仲由。”\n　　“你是孔丘的门徒吗？”\n　　“是。”\n　　现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面？我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好！”\n　　这里我先解释两个词。什么叫“避人”呢？避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他恓恓惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”？在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望；从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。\n　　再回头说子路被这两人教训得一愣一愣的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完，不尽的迷惘。谁说这两位隐士说得不对呢？这不也是孔子自己内心中常有的感触吗？但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗？他有教无类，诲人不倦，门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗？于是他感慨万端：“人总不能与鸟兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和谁生活在一起呢？他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗？假如天下有道，还需要我们吗?”\n　　《论语》中的这一段，很传神，两千多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。他恓惶而寂寞，迷惘而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他问稼，问为圃，大概也是准备避世了吧。望望眼前，路漫漫其修远兮，看看身后，追随者渐渐寥落。“道不行，乘桴浮于海，从我者，其由与！”（道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的，可能只有一个仲由了吧！）　　这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者”（我从未见过一个喜爱德行比得上喜爱美色的人。）“吾未见刚者”（我未见过刚强的人）“吾未见好仁者，恶不仁者”，（我未见过喜好仁厌恶不仁的人）“末闻好学者”（没听说过好学的人）。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗？要让这些弟子们“无欲则刚”、“好德如好色”都不可能，更何况别人？韩非就曾刻薄尖酸地揶揄孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么？而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向慕仁义的人是多么少啊。孔子此时的处境，真是令人同情。\n　　但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”（三军可以更改主帅，匹夫却不能逼他改变志向）。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容玷污？天下一团漆黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行！我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意孤行的人必有大精神，大人格。\n　　一位楚地的狂生曾经警告过孔子：“往者不可谏，来者犹可追。已而已而，今之从政者殆而！”（你过去糊涂就算了，以后你可改了吧！算了吧算了吧！现在追随政治危险得很啦！）但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”——政治，就是对暴政的矫正！就是正义！所以，孔子庄严宣告：“志士仁人，无求生以害仁，有杀身以成仁。”虽然他也说过“危邦不入，乱邦不居，天下有道则见，无道则隐”之类的话；虽然他也称赞蘧伯玉：“邦有道则仕，邦无道则卷而怀之”，宁武子“邦有道则知，邦无道则愚”，并慨叹“其知可及也，其愚不可及也”（他的聪明别人是比得上，他的糊涂别人就比不上了），大有郑板桥“由糊涂入聪明难，由聪明入糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史鱼一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样，正道直行，永不回头。\n　　自魏晋以后，中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之、闭目养神的隐君子！他们的伦理关怀哪里去了？他们的道德痛苦哪里去了？作为知识分子，他们的基本人道精神哪里去了？难道我们不应该要求知识分子有起码的价值关怀吗？但我们却偏偏认为他们是涵养最高、道德最纯洁的人！鲁迅禁不住对这些人怒形于色：泰山崩，黄河溢，隐士目无见，耳无闻！这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭桶酒囊茶壶甚至权势的尿壶么！现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。\n三　　孔子的哲学核心是“仁”。在《论话》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁”没有“一以贯之”的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。\n　　“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能”求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是，造次必于是”，何曾有—丝—毫的媚俗之态！他正大光明，磊磊落落，他一意孤行，坦坦荡荡。\n　　他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做！他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了，而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心？不辉煌何以长人志？但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投入是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。\n　　孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎？死而后已，不亦远乎？”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定？因为他们任重道远。为什么说他们任重？因为他们是把仁当作自己的人生责任的；又为什么道远？因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么—个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次！\n　　那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了：\n　　子路从而后，遇丈人。以杖荷蓧。\n　　子路问曰：“子见夫子乎？”\n　　丈人曰：“四体不勤，五谷不分，孰为夫子？”植其杖而芸（耘）。\n　　子路拱而立。\n　　止子路宿。杀鸡为黍而食之。见其二子焉。\n　　……\n　　子路曰：“不仕无义。……欲洁其身而乱大伦！君子之仕也，行其义也。道之不行，已知之矣。”\n　　这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗？减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗？我们这个民族的历史与文化会因此更加辉煌灿烂吗？我们这个“文明古国”就会更加文明吗？\n　　另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗？或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗？这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗？如果不是这样，他即使证出了1+2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗？我的这种问法不是没有道理的，二十多年前，我们就这么干过。否则，要办那么多的“干校”干什么?\n　　樊迟问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗？孔子的回答：“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来？你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院生问博士生导师吗？\n　　以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸（耘）”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子比呢？他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耘的是什么荒？是文化之荒！所培养的是什么苗？是文化之苗！柳诒徵《中国文化史》云：\n　　孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔子而传，自孔子以后数千年之文化赖孔子而开。\n　　孔子所给予我们这个民族的，甚至全世界的，又如何能估量？又如何是小农思想满脑子的人所能理喻、所能批评的？\n　　所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人孱弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器，对铁器时代绿林好汉手中青锋长剑的批评。\n　　我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而麋集到周作人羽翼下的一些人，他在这个社会里占有了比别人好—些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必至少有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说，他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的，掩盖自己的智慧，就是对社会的背叛；隐匿自己的发现，就是对社会的犯罪——当然，这种行为在专制社会里可能是迫不得已的。\n四　　因为怕孔子到楚国后说陈蔡诸侯的不是，陈蔡的小政客们便把孔子围在郊野。小政客毕竟是小政客，他们把孔子围住后，却拿不准到底要怎么样。面对一位文化巨人，他们的内心毕竟很虚怯。他们很憎恨孔子文化人格的光芒，所以，他们把他包围起来，试图挡住这光芒的四射，但他们又绝没有胆量去迫近光源——于是在陈蔡之野，便有了这样一种既滑稽又尴尬的场面：里面的人出不去，外面的人也不进来。彼此都迫切希望有一个第三者出现，来给大家一个台阶下。在第三者楚昭王派兵迎接孔子之前，孔子和他的弟子们在饥肠辘辘与满脸菜色中进行一番有趣的对话，其主题是讨论道与势的关系。\n　　孔子的知音司马迁在记叙这一段历险时，把孔子的人格精神写得淋漓尽致。据司马迁记载，此时的孔子，有意识地利用这次挫折，来考验、考查弟子们对道的忠诚贞定。孔子先叫来子路，问他：“难道我的主张不对吗？我为什么落得这个下场？”忠厚的子路疑疑惑惑地说：“是不是我们还不仁呢？人们不信任我们？是不是我们还不智呢？人们不放心我们？”悲愤的孔子说：“仲由啊，你听着，假使仁义的人一定受信任，怎么会有饿死首阳山的伯夷和叔齐？假使智慧的人一定行得通，怎么会有被纣王挖腹剖心的王子比干？”子贡进来了，孔子用同样的问题问他，子贡说：“老师，你的道太伟大了，所以这狭隘的世界容不了你。你能不能稍微降格以求呢？”孔子说：“赐啊，好的农夫只问耕耘不问收获，好的工匠只追求技巧而不追求苟顺人意，作为君子，修习大道，是不能讲苟合的啊。”\n　　最后是颜回入见，这位比孔子小三十岁的小学生，聪慧谦让，悟性高，不爱显山露水，能过苦日子，深受孔子的喜爱。他的回答，令先生愁肠顿开：“夫子之道至大，故天下莫能容。虽然，夫子推而行之，不容何病？不容然后见君子！夫道之不修也，是吾丑也，夫道既已修而不用，是有国者之丑也。不容何病！不容然后见君子！”孔子欣然而笑，说：“说得好啊，颜家小于！将来你发财时，我给你赶车吧！\n五　　孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了，不能再奔波了，况且奔波又有什么收获呢？于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰，但心如止水却是必然的。鲁君无意用他，他也懒洋洋的不求用了。回到自己阔别多年的老屋，撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了，乱臣贼子们活得更神气了，但也令他更无奈了。宝剑折断，铩羽而归，他还能做些什么呢？他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后，他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后，他的影响力却遍及全世界，名声响彻天下。\n　　孔子本来是想通过立功来传名后世的，像他终生倾慕的周公一样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉！”（君子很惧怕死后没有名声留传啊）于是他便想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。“三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”，而为后世不断地钻研，又在这不断的琢磨中发出历久弥新的光芒。\n　　那本“饥者歌其食，劳者歌其事”的三百零五首“诗”，记录着那么遥远时代的真切的痛苦，更是因为他的手订，由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之首，“子曰”与“诗云”并称。实际上，就是因为“孔子曰”，孔子的赞誉，《诗》中愚夫愚妇们的“云”，才成为中国古代文学的圣经。他对这三百首《诗》说过些什么呢？他和子夏讨论过“巧笑倩兮，美目盼兮”；他和子贡讨论过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说，“《诗》可以怨”！他把《诗》当作教材，传授给弟子们，正是因为这种口耳相传式的传授，才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火，斯文不灭。他还庄重地为《诗》回护，说：“《诗》三百，一言以蔽之，曰思无邪！”这就使后世很多对《诗经》暗怀不满的人，比如朱熹，只能做些鬼鬼祟祟的歪曲的勾当。孔子是文学的守护神呢。原来他不仅是一位庄严谨恪的人，还是一位情感丰富的人！因此，他不仅要求人类要有道德，就是对人类的情感——包括对人性的弱点，他也有那么多善意的回护与爱惜！他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。\n　　说到这里，插入一件小事。跟孔子学语言修辞的子夏，有一个毛病，那就是吝啬。知生莫如师，孔子深知子夏这一毛病，于是就刻意为他遮掩。一次孔子出门，碰上下雨，而子夏有伞，孔子却不去借，甘冒雨淋之苦。有人问孔子为何不问子夏借伞，孔子说，子夏有这个小毛病，若向他借伞，借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗？如果能掩盖住别人的缺点，我淋点雨算什么呢？\n　　文学是人学，文学就是人性的表现。不能对人性的优点有极崇高的敬意，对人性的弱点有极宽厚的怜悯，是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有一丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人（这就是“乐而不淫”），做了妻子后她辛勤贤慧，但最后还是被抛弃了，即便这样，她也依然那么理智，节制，哀而不伤，怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”（唉，算了吧），是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理，但我觉得这才合情。美狄亚就实施了惨烈的报复么。孔子也提倡“以直报怨”么。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙，很没有人性。他说：“此淫妇为人所弃，自叙其事以道其悔恨之意也”（这个淫荡的女子被别人始乱终弃了，自己追叙自己的所作所为，倾吐出悔恨之意）”读到这样的议论如果不觉得朱熹卑鄙下流，就不是正派人。因为朱熹凭空污人清白（在这首诗中一点也看不出这个女子有什么淫荡的地方）；他对一位多情的恋人（婚前）一个贤淑的妻子（婚后）毫无首肯之意，理学家之不懂欣赏女人，于此可见一斑，而理学家之仇视—切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知“以理杀人”的后儒们，他们何曾及得上孔子的一分—毫啊。\n　　由于孔子丰富的文学情怀，他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己，而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑戟，而是更加的幽默生动。你看他说的：“志于道，据于德，依于仁，游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是“成于乐”而“游于艺”！他一下子变得亲近了，不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么？他是一位手之舞之、足之蹈之的老顽童哩！他极爱音乐，即便在围困之中，也是每日“弦歌不衰”，只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件轶事：他在师襄子那里学了一首曲子，一连弹了十数天还不换其他曲子，直到他从这首曲子里“听”出了那个肤色黝黑、身材顾长、眼神忧郁的文王的形象！“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人么？孔子的精神通过飞翔的音符而与之相通了！\n　　有这样的音乐修养与音乐情怀，“三百五篇孔子皆弦歌之。”这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了，“此曲只应天上有，人间哪得几回闻”。但那古老而简朴的文字仍留传下来，那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活，是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛……\n　　《诗经》中有一百六十首都是采自民间，包括黄河流域，汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘陇与庄稼，贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢？还有什么比这更快乐的工作呢？\n　　——冬日的蛰居过去了，春光融融，芳草萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤……\n　　我在村落间徘徊，看顽童嬉闹；我亦走上田头，看麦苗油油，静观灌溉之水汩汩流淌。\n　　多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了，哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人……\n　　在还处飘来的歌声面前，我老泪纵横。\n　　我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时，他不也是感怀万端呢？“四方有羡，我独居忧。民莫不逸，我独不敢休”（《十月之交》），这样的句子，如此贴切他忧患人生的情怀，如此真切地反映他奔波为天下的辛苦，他能不感慨吗？而那一位走过周朝旧都，面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗？面对伟大朝代的文化废墟，他不更是忧患满怀吗？“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉？”（《黍离》），是啊，孔子，他是—位什么样的人呢？\n六　　《尚书》之流传具有传奇色彩，我们今天读到的本子乃是东晋豫章内史梅赜所献的《孔传古文尚书》。这个“孔”字乃是孔安国，司马迁的老师。他也是孔子的十一代孙。而这个孔安国所传的《尚书》，乃是汉鲁共王从孔子故居的墙壁中得到的。光这—点，就可知孔子与《尚书》之关系了。\n　　如果说《诗经》是中国历史上最早的诗歌总集，那么，作为“上古之书”的《尚书》乃是中国历史上最早的散文集。同时，如果说《诗经》是民间的（风、雅都可以算作是民间的），那么《尚书》就是朝廷的。《诗》是民间的情感，《书》是朝廷的意志。《诗》是抒情的，《书》是理智的。《诗》是散漫的，《书》是约束的。\n　　《诗》唱个性感受，《书》倡国家价值。《诗》是艺术，《书》是道德。《诗》是大地，是天空，是大地上的野花，是天空中的飞鸟；《书》是庙宇，是碑石，是庙宇中的祖训．是碑石中的缄言。《诗》是音乐《书》是建筑，谢林说，音乐是流动的建筑，建筑是凝固的音乐。没错，《诗》是意志的流动，《书》是情感的凝固……我们民族最古老最本质的东西，都积淀在《诗》、《书》之中了。它们都与孔子有关。\n　　《易》据说最初乃是“大墙文化”，乃是周文王为商纣所拘押，在狱中无聊，又担心自己就此玩完，“没世而名不称”，推演而成。但文王的《周易》，纯属卜筮之书，对一般读者不啻天书。“孔子晚而喜易，序《彖》，《系》，《象》，《说卦》，《文言》，谈《易》，韦编三绝”（《史记》）。他的研究成果，经口授学生，学生整理成册，始有“十翼”，翼者，辅翼，辅助理解也。应该说，孔子是把卜筮之书改造成了哲学之书，综合天地人，探究天道人道，从“究天人之际，通古今之变”而“成一家之言”。所以，就《易》在这个意义上影响中国传统文化，我们又是在这个意义上理解《易》，毋宁说，《易》乃是孔子的著作了。孔子晚年，一边穷年兀兀以研《易》，一边却又担心时不我与，叹息道：“假我数年，若是，我于《易》则彬彬矣”。天不灭斯文，孔子而后，《易》果然彬彬而盛。“易者，易也，不易也。”这截然不同却又相辅相承的训释，恰好表明了天道人道的反复，变与不变的统一。《诗经》说：“鸢飞戾天，鱼跃于渊”（《早鹿》）《易》言：“天行健，君子以自强不息”“天地之大德曰生”，这是一个生机盎然蓬勃如斯的宇宙，这也是一个满腹忧患、自强不息的人生！\n　　《礼》《乐》亦是孔子的教化工具。孔子对枯燥乏味的周代官制、礼仪的记录《仪礼》进行研究，指出其内涵、作用与本质。这一切都不过是“托古改制”而已。孔子说：“夫礼，先王以承天之道，以治人之情”，仍然是天道与人道。伟大的周公盛世初建，创建周礼，规范一个大帝国的行为与思想，开创了灿烂的周文化；伟大的孔子身当乱世，礼崩乐坏，他所做的，乃是在文化废墟上的考古、整理与保存。帝国的庞大躯体，已然僵仆，他已不能使之复生，他能做的乃是使帝国的精神与文化长存人间。他所唱的，乃是伟大文化的挽歌，世运不可回，人事有兴替，挽歌者，挽留之歌也！\n　　在《礼运》的记载中，孔子根据可考历史的发展情况，预见着未来的道路。他认为，人类社会之发展经历着三个阶段：据乱世，升平世和太平世。据乱世就是他所处的时代了，而他为后人设想的“太平世”是什么样子呢？　　天下为公，选贤与能，讲信修睦。故人不独亲其亲，不独子其子。使老有所终，壮有所用，幼有所长，鳏寡、孤独、废疾者皆有所养；男有分，女有归。\n　　谁说孔子只是向后看呢？他也展望未来啊！只是这位衰弱的老人自知自己是等不到那黄河清的一天了！\n　　《乐记》也还是在谈哲学，谈政治：\n　　(音乐)清明象天，广大象地。终始象四时，周还象风雨……乐行而伦清，耳目聪明，血气和平，移风易俗，天下皆宁。\n　　好像不能一味指责孔子把文艺都搞成道德教化，都搞成政治蓝图。你看他所处的是什么时代？一个“仁以为己任”的思想家，他不关心天下不宁，还关心什么？他不祈望天下皆宁并为之奋斗，他还祈望什么？让他回到家里，关上门，温壶春酒，泡杯苦茶，弹琴逍遥吗？\n　　最后就要谈到《春秋》了。这是使一个时代都因此而得名的著作。\n　　晚年的孔子顾视日影，喟然叹息：“不行啊不行啊，君子很惧怕死后没有留下名声啊。我的道行不通了，我凭什么在后世传名呢？”他搬来鲁国历代太史记录的史料，开始著作历史。以前在做官审案时，他很谦虚地与其他陪审官商定判辞，而此时他却突然“专断”起来，“笔则笔，削则削，子夏之徒不能赞一辞”。连插嘴提建议的机会都不给！这本以“微言大义”著称的历史著作，孔子是有意把它写成政治学著作、伦理学著作的！他在这里要审判的，是整个历史！而且他所进行的不止是历史批判，更重要的倒是他的政治批判与道德批判！他希望他的这本书能成为人的道德准则，更希望它能建立一种合理有序的政治运行法则。这就是这本书使“乱臣贼子惧”的原因。\n　　孔子在给弟子们讲授《春秋》时感慨地说：“后世知丘者以《春秋》，而罪丘者亦以《春秋》。”丘吉尔说，影响历史的最好方法就是写历史，“春秋”以后的历史，不都受着《春秋》的影响么？孔子一直在参与着历史进程啊。只是他本人没有到场罢了，对后来的历史而言，他只是一个缺席者。\n七　　我认为，孔子最伟大的贡献乃是他的“私学”。最初开办私学的人未必就是孔子，但把私学办成传授文化、培养人格、培养知识阶层的场所，则毫无疑问是孔子。正是在他的私学里，才出现了中国历史上第一批真正意义上的知识分子。——这些人既不是世袭贵族，也不是后来的科举士大夫，他们不是官僚机构中的成员。他们是那时代冒出来的“新人”，名称叫“士”，后来孟子宣称“大德者不官不王”，魏文侯之师田子方宣称“行不合，言不用，则去之楚越，如脱屦然。”可以见出这些人的傲慢与偏见——对诸侯的傲慢是那么显眼，对学问的偏见又是那么深固。\n　　谁培养了这一批特行独立的知识分子？是孔子。上引的孟子与田子方都是孔门后学。所以，孔子的私学促成了文化的独立，文化由权势者股掌之间的小妾，蜕变为特行独立的汉子，“大丈夫”（孟子语）。这种文化不以取悦权势换得宠爱为目的，而以社会批判为天职。文化而以社会批判为天职，这就是文化的本质属性了。谁赋予了文化这种本质属性？是孔子。对于世俗政权而言，权力体制自身的制衡是必要的，重要的；而文化批判所产生的文化制衡尤其重要。中国后来漫长的封建社会里，之所以没能在权力体制之中产生制衡，这与封建政权把文化纳入权力体制，取消其独立性，否定其文化批判的必要性合理性有极大的关系。也就是说，当我们否定了文化批判之后，权力内部的制衡也就相应的被消解。官僚系统之内的权力制衡是为了政府及其各职权部门行为的合法有序及防止权力滥用；而文化批判所产生的制衡则是保证整个社会的行为合乎人性，合乎理性。孔子以后的百家私说，不都是在这个意义上讨论世俗政权的合理性么？\n八　　孔子曾描述过自己的形象，“学而不厌，诲人不倦，不知老之将至”。在他的身边，一批勤奋好学安贫乐道的年轻人在成长着。看看这些蓬勃的春花，他真的就想不到自己已是秋天的一枚黄叶？这句话我看应该这么理解，正是因为知道自己老冉冉而将逝，才抱定“朝闻道，夕死可矣”的信念与日逐走，学而不厌。同时又把自己的心得传授给弟子们，诲人不倦他已是明白地知道，自己来日无多了！鲁迅晚年自知不久于人世，便一再告诫自己要“赶紧做”。孔子也是在与自己的生命赛跑，赶紧做呵。“天下无道久矣，而莫能宗予，”他已无力回天了，“道不行，乘桴浮于海”，他要离开我们去那道山了！\n　　颜渊死了，他的精神受到沉重的打击。“天丧予！天丧予！（天要灭我，天要灭我啊！）安贫而乐道的颜回死于贫困，死后连棺材也没有。孔子为之深深恸哭。“我不为他哭还为谁哭呢？”他越来越老了，世道也越来越混乱了，不久，有消息传来，仲由死在卫国了，正中了孔子以前的忧心忡忡的预言：“不得其死”，被人剁为肉酱。仲由是众弟子中唯一敢于冲撞他的学生，小他九岁，总是雄纠纠的样子。孔子知道这个有些粗野的弟子其实最为忠厚义气，他还曾设想，当他远遁人世时，让仲由跟随着他。可现在又死在他前面了。他已经多次承受着这白发人送黑发人的惨痛了。他的心境更为凄凉了。做生意的端木赐（子贡）来看他，给老师一些周济，他正拄着拐杖在门外看西山的落日，那落日如血的余辉最后一次染红大地与天空。孤独的孔子问端木赐：“赐啊，你为什么到现在才来看我呢？”接着便低吟了一首绝命歌，那简单的字句和厚重的内涵使人想到宇宙中最简单而又最本质的哲理，人间的生死竟也牵动着宇宙的毁成：\n　　太山坏乎！\n　　梁柱摧乎!\n　　哲人萎乎！\n　　圣人洒泪而尽了。带着他的雄心去了。如蜡烛最后一次耀眼的一跳，熄灭了。天地之间，一片黑暗。但，也就是从那一刻起，他不再仅属于一个时代，而属于千秋万代！\n 　　痴人有多种，或因情深而痴，或因智浅而痴，孔子属于前者，而他的很多徒子徒孙，如宋明之际的理学家们，就属于后者了，新儒家们当更是等而下之。因情而痴的孔子常常沉湎在过去的怀想之中，“郁郁乎文哉!吾从周：”“逝者如斯夫!”这时，他就是一位抒情者，抒得很动情，很感人。在一个抽象的、冷酷的、沉闷的老子之后，出现一个一往情深、感怀万端的孔子，使我们再次感受到一种温软，一种熨帖，这实在是让我们大大舒了一口气，历史终于在绝望中咧口而哭出了声，一些可怕的心理能量在孔子的歌哭、幽默、感喟中被释放了。孔子使一些无序的暴力变成了有目的、有方向的努力与企望，他使天下英雄人于他的彀中，带着这些社会精英致力于建构新的理想。当混乱的历史有了理想与方向时，混乱就不再是一无是处，相反，倒往注显示出一种蓬蓬勃勃、生机无穷的魅力。\n　　春秋战国时代是一个刀光剑影的时代，一个流血漂橹的时代，一个杀人盈城、杀人盈野的时代，但它不也是一个充满理想、充满激情，充满公理仁德的时代吗?谁开辟了这样的时代?是孔子！非常具有象征意义的是，当孔子子和弟子们周游列国的时候，他往往自己驾车一一他确实是在驾着这个时代的马车。弟子们在车上或呼呼大睡或哈欠连天．一脸凄迷与怀疑。只有他永远目光炯炯，自信目标就在前方。\n　　有一次。在一条汤汤而流的小河边。他们又找不到渡口了。远处的水田中有两人在耕作，子路便上前去打问。其中的一个细长个子却不回答子路的询问，而是反问子路：\n　　“那个执缰绳的人是谁？”\n　子路恭敬地回答：“是孔丘。”\n　　“是鲁国的那个孔丘吗?”——可见孔子的知名度颇高。\n　　子路答：“是。”这个细高个冷冷地就来了一句：“既然是鲁国的那个孔丘，他应该知道渡口在哪里嘛。”\n　　没奈何，已经由绿林好汉改邪归正到孔子门下的子路，只能捺住火气，转过身去问另一位。这一位魁梧雄桀，是个大块头。大块头也反问子路：“你是谁?”\n　　子路仍然是恭敬地回答：“我是仲由。”\n　　“你是孔丘的门徒吗?”\n　　“是。”\n　　现在又轮到大块头来教训子路了：“天下混乱，举世皆然。谁能改变这种局面?我看你身体强壮，是个好庄稼汉。与其跟随孔子这样的避人之士东奔西走，鼓唇摇舌，倒不如跟随我们这些避世之士，躬耕垄亩的好!”\n　　这里我先解释两个词。什么叫“避人”呢?避人就是择人，就是避开那些昏庸无道的诸侯，而去寻找志同道合的有为之君，一同来重整乾坤。良禽择木而栖，贤才择主而事嘛，不择主，只要给富贵就帮他卖力，那是苏秦张仪的作为。孔子一心要的是救世，而不是个人富贵，所以他栖 惶惶的马车在纵横阡陌间奔走扬尘，就是要避开身后的昏君而去寻找前面的明君。什么是“避世”?在“避人”的基础上再跨一步，彻底冷了心，闭了眼，认定天下不可能有什么诸侯还能与他一起改变这世界，于是彻底绝望，从而彻底不抱希望，回到田园中去，回到自己的内心中去，告别都市、政治与熙熙攘攘的外部世界，就叫避世。\n　　再回头说子路被这两人教训得一楞一楞的，又要注意自己此时的身份，不能发作，只好垂头丧气地回来向孔子汇报。孔子听完。不尽的迷悯。谁说这两位隐士说得不对呢?这不也是孔子自己内心中常有的感触吗?但他历尽艰辛，学而不厌，“十年磨一剑，霜刃未曾试”，难道就此卷而怀之吗?他有教无类，诲人不倦。门徒三千，贤者七十二，就是为了培养一批隐士，或者懂文化的农夫吗?于是他感慨万端：“人总不能与乌兽一起生活在山林之中啊，我不和芸芸众生生活在一起，与他们共享欢乐共担不幸，我又能和淮生活在一起呢?他们说天下无道，但不正因为天下混乱无道，才需要我们去承担责任吗?假如天下有道，还需要我们吗?”\n　　《论语》中的这一段，很传神，两干多年了，那条汤汤小河边发生的这场争论就好像发生在昨天似的。这几个人好像还在我们身边。我尤其为孔子感动。惜惶而寂寞，迷悯而执拗。“志于道”的人越来越少了，不少人顺应潮流，从而成了新贵，或成为新贵的红人，其中甚至有他的门徒，比如那个顶善于察言观色的弟子冉求。又有不少人冷了心，折断宝剑为锄犁，平戎策换得种树书，如长沮，桀溺；其中也有他的弟子，如樊迟。樊迟向他稼、问为圃，大概也是准备避世了吧。望望眼前。路漫漫其修远今，看看身后，追随者渐渐寥落。”道不行，乘俘浮于海，从我者，其由与!”(道行不通了，我只能乘小船漂荡到大海中去了。到那时还能跟随我的、可能只有一个仲由了吧!)这位可敬可叹的老人，想凭自己个人的德行与魅力来聚集一批年轻人，让他们传道义之火，文化之火；拯民于水火，匡世于既颠，但年轻人不容易经受得了各种诱惑，“吾未见好德如好色者’’(我从未见过一个喜爱德行比得上喜爱美色的人)“吾未见刚者”(我未见过刚强的人)“吾未见好仁者，恶不仁者”(我未见过喜好仁厌恶不仁的人)“末闻好学者’’(没听说过好学的人)。这些话不也把他的三千弟子甚至七十二贤者都包括在内了吗?要让这些弟子们“无欲而刚”“好德如好色”都不可能，更何况别人?韩非就曾刻薄尖酸地椰榆孔子，说凭着孔子那么巨大的个人德行，不就只有七十子之徒跟随他么?而下等君主鲁哀公却能让一国人都服从他，孔子本人也不得不向鲁哀公臣服。所以，人是多么容易向权势屈服，而向幕仁义的人是多么少啊。孔子此时的处境，真是令人同情。\n　　但他更让我们尊敬。这就是他的那种“知其不可而为之”的殉道精神。“三军可夺帅也，匹夫不可夺志也”(三军可以更改主帅、匹夫却不能逼他改变志向)。匹夫尚且不能夺志，更何况圣人之志，得天地浩然正气，至大至刚，岂容站污?天下一团混黑了，不少原先追求光明的人也练就了猫头鹰的眼睛，从适应黑暗而进于喜欢黑暗，为黑暗辩护，他们把这称为提高了觉悟和认识，并且得道似的沾沾自喜于在黑森林中占据了一棵枝丫，又转过头来嘲笑别人不知变通。而孔子，这位衰弱的老人却在那里一意孤行!我很喜欢“一意孤行”这个词，很喜欢这个词所指称的那种性情与人格。敢于一意现行的人必有大精神、大人格。一位楚地的狂生曾经警告过孔子：”往者不可谏，来者犹可追。已而已而，今之从政者殆而!”(你过去糊涂就算啦，以后你可改了吧：算了吧算了吧．现在追随政治危险得很啦：)但不能因为政治危险，就置天下苍生于不顾，听任他们受暴政的煎熬，置自己的伦理责任于不顾！“政者，正也”—一政治，就是对暴政的矫正：就是正义！所以孔子庄严宣告：“志士仁人，无求生以害仁，有系身以成仁。”虽然他也说过：“危邦不入，乱邦不居，天下有道则见，无道则隐’’之类的话；虽然他也称赞遽伯玉“邦有道则仕。邦无道则可卷而怀之”，宁武子“邦有道则知，邦无道则愚”、并慨叹“其知可及也，其愚不可及也”(他的聪明别人能比得上，他的糊涂别人就比不上了)，大有郑板桥“由糊涂入聪明难，由聪明人糊涂尤难”的意味，但他对自己，却有更高的要求，那就是如史色一样，“邦有道，如矢，邦无道，如矢”，永远是如射出的箭一样、正道直行，永不回头。\n　　自魏晋以后。中国的文化传统中，就有了一种极古怪的现象，那就是人格理想与伦理责任的分离。最受人敬仰的人格乃是那些在天下苦难面前卷而怀之，闭目养神的隐君子!他们的伦理关怀哪里去了?他们的道德痛苦哪里去了?作为知识分子，他们的基本人道精神哪里去了?难道我们不应该要求知识分子以起码的价值关怀吗?但我们却偏偏认为他们是涵养最高，道德最纯洁的人!鲁迅禁不住对这种人怒形于色：秦山崩，黄河溢，隐士目无见，耳无闻!这种目不关注人间苦难，耳不听弱者呻吟的人物，不就是饭捅酒囊茶壶甚至权势的尿壶么!现在不少人飘飘然地要“告别鲁迅”，却又腻歪歪地对“茶壶”周作人大为钟情。这种人是难以让人生出敬意的。一个人让人尊敬是有条件的。在孔子那里，在他的学说之中，那种古典的崇高确实让我们这些聪明机灵的后来人愈显扁平而单薄。\n　　孔子的哲学核心是“仁”。在《论语》中，“仁”以不同的面目，在不同的背景下出现了无数次。这些闪烁不定的面容并不是因为孔子的“仁’’没有“一以贯之’’的主旨，而恰恰说明了“仁”内涵的丰富。樊迟问“仁”，孔子答曰“爱人”；颜回问“仁”，孔子答曰：“克己”，曾子概括说，“夫子之道，忠恕而已”。朱熹解释说，尽自己的力量去办事叫忠，推己及人叫恕。这样看来，孔子的“仁”，也就是从人我双方立论，相当于我们今天常说的“人类共存意识”吧。“仁”的内涵里，主要的两方面就是“忠”和“恕”。有了这个“忠”，就会有足够的自我约束；有了这个“恕”，就会有足够的对别人的宽容。这个顶重要了。孟子后来讲“仁”，就不大讲“恕”了，这就一步一步走向专制。孟子就没有孔子可爱。当然，孔子的“仁”，不仅仅是指一个人应当具有的人格境界，而且还应该是一个社会政治应当具有的政治理念。是公理，是正义。因而，在非常时刻应当“杀身以成仁”，而决不能“求生以害仁”。他自己一生，倡导“仁”，实践“仁”，修自身为“仁”，又要改造社会政治为“仁”。修自身成“仁”，他是做到了，改造社会政治为“仁”，他失败了。但他“颠沛必于是造次必于是”，何曾有一丝一毫的媚俗之态!他正大光明，磊磊落落，他一意孤行，坦坦荡荡。他亦知道改造社会是不可能的，但他“知其不可而为之”，关键在于做!他肯定已经意识到了他在未来的影响，所以他要用自己的行为树立一个榜样，以自己的生命之汁点亮一盏明灯，使后世一切以各种借口逃避伦理责任的行为无所遁形。——既然他已经在知其不可的情形下做了．而且做得如此艰苦，如此卓绝，如此寂寞，又如此轰轰烈烈，如此失败，又如此辉煌灿烂。因失败而辉煌，我以为这是古典悲剧的基本定律，不失败何以感人心?不辉煌何以长人志?但这失败必须是大失败，必须是必然的失败，是自由在逻辑面前的失败，是个人意志在历史规律面前的失败，而且必须是主人公已经预知的失败。他已经预先知道结局了，但高傲的心性使他无法改变自己人生的方向。在古典悲剧中，生命的投人是人格成就的最后一道工序，如干将莫邪之铸剑，最后必以自身的血肉之躯投入熔炉，用自己的血光赋予宝剑以阳刚杀气。孔子的“得其真传”的弟子曾参，有一段话：“士不可不弘毅，任重而道远。仁以为己任，不亦重乎?死而后巳，不亦远乎?”我无法不为这句话而感动，虽然我已经被那些最靠近话筒，因而最有发言权的某些人的这个“后”那个“后”，还有什么“解构”，解构得没有什么完整的心智了。曾子的这段话包含着两个推论，所以我们可以把它译成问答句：士为什么要弘大坚定?因为他们任重道远。为什么说他们任重?因为他们是把仁当作自己的人生责任的；又为什么道远?因为他们除非死掉，不然就不能卸下这副担子。这就是自讨苦吃式的崇高。我上文说，让人尊敬是有条件的，不能因为你读 了不少书，甚至读了不少洋文书，知道各种主义，就能受人尊敬。你还得有所承担。孔子及其弟子们，在那么一个时代，就已经意识到担当道义是知识分子的最高使命甚至无法摆脱的宿命了，就已经知道执行文化批判而不是文化媚俗文化献媚是知识分子的基本职责了，他们怎能不伟大，又怎能不为这伟大而颠沛，造次!\n　　那些冷了心肠的隐士讽刺孔子，还有些愤世嫉俗的道理。而下面这位“丈人”对孔子的批评就莫名其妙了：\n　　子路路从而后，遇丈人。以杖荷條。\n　　于路问曰：“子见夫子乎?”\n　　丈人曰：“四体不勤，五谷不分，孰为夫子?”植其杖而罢(耘)。\n　　子路拱而立。\n　　止子路宿。杀鸡为泰而食之。见其二于焉。\n　　子路曰：“不仕无义。……欲洁其身而乱大伦!君子之仕也，行其义也。道之不行，已知之矣。”\n　　这一段中的“四体不勤，五谷不分”，后来成为不少人批评孔子的口实。是的，在一个小农意识很浓厚的国家里，这种情形较易发生，并且较易引来阵阵喝彩。甚至人们还能这样想：你孔子子四肢不勤劳，五谷分不清，你连一个农夫都比不上。这种说法会引来更多的喝彩，因为很多人一下子从孔子的缺点中找回了自己的自信心。——但我要说，这种批评的荒谬性太明显了。在春秋后期，我们缺少一位农夫吗?减少一位卓越的思想家，增添一名普通的农夫，我们就是这样算账的吗?我们这个民族的历史与文化会因此更加辉煌灿烂吗?我们这个“文明古国”就会更加文明吗?另外，我们民族在那个时代连养活一位像孔子这样的大思想家的经济能力都没有，还必须让他自己去耕种自存吗?或者，我们这个民族连给孔子这样的大思想家提供必要的生活条件都不愿意，而必欲使之和农夫一样才心满意足吗?这些问法可以换成现代式的：我们必须分给陈景润一块自留地，由他自己播种，收获，磨粉，蒸馒头，吃下去，然后再去桌子边求证他的哥德巴赫猜想吗?如果不是这样，他即使证出了l十2，由于他不会蒸馒头，于是我们就可以鄙夷他连一个馒头师傅都不如吗?我的这种问法不是没有道理的，20多年前．我们就这么干过。否则，要办那么多的“干校”干什么?\n　　樊迟向他问稼问为圃，孔子怒不可遏，甚至在背后骂他是“小人”。又有不少人说这是孔子轻视体力劳动，现在的某些大学教材上就有这种说法。这种批评也太师心自用了。问如何种菜种小麦，需要问孔子吗?孔子的回答是“我不如老农民，我不如老菜农”，已经说得很明白了：你樊迟要学这些，你何必到我这儿来?你去问老农即是。要学腌泡菜蒸馒头切土豆丝，需要去中科院问博士生导师吗?\n　　以上的问题还在于，培养一个老农易，至少在孔子那时，还不提倡科学种田时是这样。那时候就没有什么农业技术学校，但遍地是老农在种麦子种大头菜。培养一个知识分子就难了。孔子的时代，传播知识，提高人口素质，似乎比自己去亲自参加劳动更迫切。所以，孔子的这些言行，与轻视体力劳动如何扯得上。这一位“植其杖而芸(耘)”的“丈人”，耘来耘去，也就那一亩二分地，所养活的，不过就是他自己及家人。这又如何能与孔子相比呢?他自己的言行能够传留后世，还是沾的孔子的光呢。孔子所耕耘的是什么荒?是文化之荒!所培养的是什么苗?是文化之苗!柳绐徵《中国文化史》云：”孔子者中国文化之中心也，无孔子则无中国文化。自孔子以前数千年之文化赖孔于而传，自孔子以后数千年之文化赖孔于而开。”\n　　孔子所给予我们这个民族的，甚至全世界的，又如何能估量?又如何是小农思想满脑子的人所能理喻、所能批评的?\n　　所以，上述的那些对孔子的批评，让我联想到今天一些人对鲁迅的批评，以及他们莫名其妙的对于鲁迅的优胜感。鲁迅的某些缺点确实让某些人民弱的心性得到一种自信的证明。但他们对于鲁迅的批评，恰像旧时代老爷家中感觉很幸福从而很温柔的小妾，对现代独身女性的批评；又好比是青铜时代贵族几案上的玲珑的酒器或床底下温静的溺器。对铁器时代绿林好汉手中青锋长剑的批评。\n　　我对古代的隐士评价不高。相应的，我对现代的周作人及其鼓吹者们也心存怀疑。我认为，一个人，比如这几年“告别鲁迅”而庚集到周作人羽翼下的一些人，他在这个社会里占有了比别人好一些的地位、财富、机会，使他能上大学读书，能明理，他理应对这个社会有所回报，有所补偿。按我们现在的大学招生数和报考数，有一个上大学的，就必有一个或更多上不了大学的。这种回报与补偿就是把自己的聪明才智贡献出来，使这个社会有所进步，人们的幸福能有所增进。也就是说。他的知识应该有益于社会，而不是把这种知识当成自己的文雅的小妾。我在一篇文章里，就认为周作人是把他的学识当小妾，只让她陪自己喝茶谈玄。而如果把知识当作取媚权力的手段，就更等而下之了。另一方面，出于某种自私的目的．掩盖自己的智慧。就是对社会的背叛：隐匿自己的发现，就是对社会的犯罪——当然．这种行为在专制社会里可能是迫不得已的。\n　　孔子晚年，倦于奔波。鲁迅曾在一篇颇似游戏的文字中推测孔子晚年有严重的胃病和胃下垂。一个医生对一个常年在坎坷的道路上颠簸的人很容易下这个判断。总之，孔子老了，病了。不能再奔波了，况且奔波又有什么收获呢?于是，在离开鲁国十四年之后，靠弟子冉求的疏通，又回到了鲁国故乡。此时孔子已是知命了，不说心如死灰。但心如止水却是必然的。鲁君无意用他。他也懒洋洋的不求用了。回到自己阔别多年的老屋。撩去门楣窗棂上的蛛网，拂去案几上的积尘，他坐下来，心境一片茫然。这时，外面的世界更混乱了。乱臣贼子们活得更神气了。但也令他更无奈了。宝剑折断．铩羽而归，他还能做些什么呢?他打开了竹简。这是一个有世界意义的举动。孔子现实政治活动的失败使中国少了一位晏婴、子产或管仲式的人物，但却使世界从此有了一个伟大文化的源头。这活力绵绵不绝的文化之源，浩浩荡荡，渐远渐无穷，使整个东方世界都浸润其中。是的，当孔子的现实政治活动失败后．他埋头于古代典籍的整理；在被自己的时代拒绝之后，他成功地通过文化符号进入了未来的世纪；在被几个诸侯国的诸侯和政客拒绝后。他的影响力却遍及全世界。名声响彻天下。\n　　孔子本来是想通过立功来传名后世的，像他终生倾慕的周公…样。但这一点已经毫无疑问地没有可能了。“君子疾没世而名不称焉!”(君子很惧怕死后没有名声留传啊)于是他使想通过立言来不朽。我们知道，在这一点上，他成功了，而且在立言中他还立了德。”三不朽”他完成了两项。据司马迁的记载，“六经”都是经他手订的。也正因了他的手，这些积满时光尘土的古典才成为“经”．而为后世不断地钻研．又在这不断的琢磨中发出历久弥新的光芒。那本“饥者歌其食，劳者歌其事”的三百零五首“诗”。记录着那么遥远时代的真切的痛苦。更是因为他的手订．由愚夫愚妇引车卖浆者流的歌吟一跃而成为六经之百。“子曰”与“诗云”并称。实际上，就是因了“孔子曰”．孔子的赞誉。《诗》中愚夫愚妇们的“云”。才成为中国古代文学的圣经。他对这三百首《诗》通过些什么呢?他和子夏讨论过“巧笑倩兮，美目盼兮”：他和子贡讨沦过“如切如磋，如琢如磨”；他说：“不学《诗》，无以言”，他还说。“诗，可以怨”!他把《诗》当作教材。传授结弟子 们，正是因为这种口耳相传式的传授．才使得《诗经》能避开暴君赢政的焚书之火和莽汉项羽的复仇之火．斯文不灭—他还庄重地为《诗》回护。说：《诗》三百，—言以蔽之．曰思无邪！”这就使后世很多对《诗经》暗怀不满的人。比如朱熹．只能做些鬼鬼祟祟的、歪曲的勾当。孔子是文学的守护神呢。原来他不仅是—位庄严谨恪的人。还是一位情感丰富的人!因此，他不仅要求人类要有道德。就是对人类的情感——包括对人性的弱点。他也有那么多善意的回护与爱惜!他要人们好德，但也不反对人们好色，“国风好色而不淫”，不过分，就行了嘛。说到这里。插入一件小事。跟孔子学语言修辞的子夏，有—个毛病．那就是吝啬。知生莫如师。孔子深知子夏这一‘毛病．于是就刻意为他遮掩。一次孔子出门．碰上下雨，而子夏有伞。孔子却不去借，甘冒雨淋之苦。有人间孔子为何不向子夏借伞，孔子说。子夏有这个小毛病，若向他借伞。借，他心里不痛快；不借，不是把他的缺点暴露给众人了吗?如果能掩盖住别人的缺点。我淋点雨算什么呢?\n　　文学是人学，文学就是人性的表现。不能对人性的优点有极祟高的敬意．对人性的弱点有极宽厚的怜悯．是不可能理解文学的。我们再举一个相反的例子，朱熹。对这个人我老实说没有——丝一毫的好感。且不说他的那一套“存天理，灭人欲”的理论是多么仇视人性，我只想举他对《诗经》中一首诗的评论来说说。\n　　《诗经·卫风》中有一首诗叫《氓》，是一位被遗弃女子的哀歌。这个女子坚持要明媒正娶地嫁给她所爱的男人(这就是“乐而不淫”)，做了妻子后她辛勤贤患。但最后还是被抛弃了。即便这样，她也依然那么理智、节制，哀而不伤。怨而不怒。老实说，我读到这首诗的最后“亦已焉哉”(唉，算了吧)．是颇失望的，我私下里希望她能报复对方一下。我知道这种想法不对，既不合法也不合理。但我觉得这才合情。美狄亚就实施了惨烈的报复。孔子也提倡“以直报怨”。但朱熹对这个不幸女子的评论，使我觉得他很卑鄙。很没有人性。他说：“此淫妇为人所弃．自叙其事以道其悔恨之意也。”(这个淫荡的女子被别人始乱终弃了．自己追叙自己的所作所为．倾吐出悔恨之意)读到这样的议论如果不觉得朱烹卑鄙下流．就不是正派人。因为朱熹凭空污人清白(在这首诗中一点也看不出这个女子有什么淫荡的地方)；他对一位多情的恋人(婚前)一个贤淑的妻子(婚后)毫无首肯之意，理学家之不懂欣赏女人．于此可见一斑，而理学家之仇视一切鲜活的女性，对人间痛苦毫无同情心也在此原形毕露。这些只知”以理杀人”的后儒们，他们何曾及得上孔子的一分一毫啊。\n　　由于孔子丰富的文学情怀。他把人格修养的最高境界理解为一种自由的艺术境界，而不是严谨的道德境界。在这一点上他又和后世的道德家们大相径庭。我们也一直没注意这一点。孔子在道德的熔炉里冶炼自己．而最后出炉的结果却大出我们意料：他熔炼出的不是森森剑朝。而是更加的幽默生动。你看他说的：“志于道．据于德，依于仁、游于艺”，又说“兴于诗，立于礼，成于乐”。他最后的形象是”成于乐”而“游于艺”：他一下子变得亲近了．不再壁垒森严了。你看他：“闻《韶》，三月不知肉味”，这时他能是一位皱着眉头板着面孔不苟言笑的人么?他是一位手之舞之，足之蹈之的老顽童哩!他极爱音乐．即便在围困之中，也是每日“弦歌不衰”。只要附近没死丧，他每日都大声地唱歌。司马迁的《孔子世家》中记载了孔子与音乐的一件软事：他在师襄子那里学了一首曲子．一连弹了十数天还不换其他曲子、直到他从这首曲子里“听”出了那个肤色黝黑、身材硕长、眼神忧郁的文王的形象!“作《易》者，其有忧患乎！”文王可不就是一个满腹忧患的古之高人吗?孔子的精神通过飞翔的音符而与之相通了!\n　　有这样的音乐修养与音乐情怀。“三百五篇孔子皆弦歌之”。这是多么宏伟壮丽的大乐章啊。我们今天已经不能再聆听孔子弦歌过的音乐了。“此曲只应天上有．人间哪得几回闻”。但那古老而简朴的文字仍留传下来。那远古时代活生生个体的欢乐与哀伤，希望与失望，怨愤与爱慕……仍然如此鲜活。是的，那远古的神经末梢仍在向我们传来敏锐而清晰的刺痛……\n　　《诗经》中有一百六十首都是采自民间。包括黄河流域。汉水、汝水流域。我们可以由此贴近这片辽阔土地上的风、水、丘垄与庄稼。贴近这片土地上的阳光、情感、悲欢与离合。班固与何休都提到当时有专门采诗的行人，摇着木铎顺着乡间小道去采诗。我有时痴想，没有比这更好的职业了。如果我在那时，我一定做个采诗者。不采诗还干什么呢?还有什么比这更快乐的工作呢?\n　　冬日的蛰居过去了，春光融融，芳香萋萋。我立于道口，望农夫荷锄远来，而他的歌声亦悠扬而感伤……\n　　我在村落间徘徊．看顽童嬉闹：我亦走上田头。看麦苗油油，静观灌溉之水汩汩流淌。\n　　那么多忧伤的故事啊。有一个人因想念远方的恋人而去了，从此杳无音信；一位多情的女子被人遗弃了．哭泣着回到娘家；而服役归来的人，拄杖立于田头，他的家园已成一片废墟，丘垄上葬着他的亲人……\n　　在远处飘来的歌声面前，我老泪纵横。\n我是被《诗经》感动了。最幸福的时候就是被感动的时候。谁能说当孔子对这三百零五首诗逐一弦歌时．他不也是感怀万端呢?“四方有羡，我独居忧。民莫不逸，我独不敢休”(《十月之交》)，这样的句子，如此贴切他忧患人生的情怀．如此真切地反映他奔波为天下的辛苦，他能不感慨吗?而那一位走过周朝旧都．面对废墟上的野黍而“中心摇摇”悲不自禁的诗人，不更是他的同调吗?面对伟大朝代的文化废墟，他不更是忧患满怀吗?“知我者谓我心忧，不知我者谓我何求。悠悠苍天，此何人哉?”(《黍离》)，是啊，孔子，他是…位什么样的人呢？\n\n","categories":["精华转载"]}]